Index: units/win32/virtualpanningwindow.pas
===================================================================
--- units/win32/virtualpanningwindow.pas	(revision 2334)
+++ units/win32/virtualpanningwindow.pas	(working copy)
@@ -38,12 +38,13 @@
 begin
   if Msg = WM_PAINT then
   begin
-    PanningObject:=TVirtualPanningWindow(GetWindowLong(Window,GWL_USERDATA));
+    PanningObject:=TVirtualPanningWindow(GetWindowLongPtr(Window,GWL_USERDATA));
     if Assigned(PanningObject) then
       PanningObject.HandlePaintMessage;
+	Result := 0;
   end
   else
-    DefWindowProc(Window,Msg,WPara,LPara);
+    Result := DefWindowProc(Window,Msg,WPara,LPara);
 end;
 
 var
@@ -87,8 +88,7 @@
   with Position do
     FHandle := CreateWindowEx(WS_EX_TOOLWINDOW, PanningWindowClass.lpszClassName, nil, WS_POPUP, X - 16, Y - 16,
       32, 32, OwnerHandle, 0, HInstance, nil);
-  //todo use SetWindowLongPtr later
-  SetWindowLong(FHandle,GWL_USERDATA,PtrInt(Self));
+  SetWindowLongPtr(FHandle,GWL_USERDATA,LONG_PTR(Self));
   
   FImage := TBitmap.Create;
 end;
Index: VTConfig.inc
===================================================================
--- VTConfig.inc	(revision 2334)
+++ VTConfig.inc	(working copy)
@@ -22,12 +22,16 @@
 
 
 //Lazarus port options
-{$define EnableOLE}
+{.$define EnableOLE}
 {.$define EnableNativeTVM}
 {.$define EnablePrint}
 {.$define EnableNCFunctions}
 {$define EnableAdvancedGraphics}
-{$define EnableAlphaBlend}
+
+{$IFDEF CPU32}
+  {$define EnableAlphaBlend}
+{$ENDIF CPU32}
+
 {.$define EnableAccessible}
 {$define ThemeSupport}
 {$if defined(LCLWin32) or defined(LCLWinCE)}
@@ -42,5 +46,5 @@
 
 //under linux the performance is poor with threading enabled
 {$ifdef Windows}
-  {$define EnableThreadSupport}
+  {.$define EnableThreadSupport}
 {$endif}
Index: VirtualTrees.pas
===================================================================
--- VirtualTrees.pas	(revision 2334)
+++ VirtualTrees.pas	(working copy)
@@ -745,6 +745,7 @@
     toAutoHideButtons,          // Node buttons are hidden when there are child nodes, but all are invisible.
     toAutoDeleteMovedNodes,     // Delete nodes which where moved in a drag operation (if not directed otherwise).
     toDisableAutoscrollOnFocus, // Disable scrolling a node or column into view if it gets focused.
+    toDisableAutoscrollHorizontal, // Only autoscroll on focus vertically never horizontally
     toAutoChangeScale,          // Change default node height automatically if the system's font scale is set to big fonts.
     toAutoFreeOnCollapse,       // Frees any child node after a node has been collapsed (HasChildren flag stays there).
     toDisableAutoscrollOnEdit,  // Do not center a node horizontally when it is edited.
@@ -2013,7 +2014,7 @@
     var Allowed: Boolean) of object;
   TVTDragOverEvent = procedure(Sender: TBaseVirtualTree; Source: TObject; Shift: TShiftState; State: TDragState;
     const Pt: TPoint; Mode: TDropMode; var Effect: Integer; var Accept: Boolean) of object;
-  TVTDragDropEvent = procedure(Sender: TBaseVirtualTree; Source: TObject; DataObject: IDataObject;
+  TVTDragDropEvent = procedure(Sender: TBaseVirtualTree; Source: TObject; {DataObject: IDataObject;}
     Formats: TFormatArray; Shift: TShiftState; const Pt: TPoint; var Effect: Integer; Mode: TDropMode) of object;
   TVTRenderOLEDataEvent = procedure(Sender: TBaseVirtualTree; const FormatEtcIn: TFormatEtc; out Medium: TStgMedium;
     ForClipboard: Boolean; var Result: HRESULT) of object;
@@ -2472,7 +2473,7 @@
     procedure CMDenySubclassing(var Message: TLMessage); message CM_DENYSUBCLASSING;
     //procedure CMDrag(var Message: TCMDrag); message CM_DRAG;
     procedure CMFontChanged(var Message: TLMessage); message CM_FONTCHANGED;
-    procedure CMHintShow(var Message: TCMHintShow); message CM_HINTSHOW;
+    procedure CMHintShow(var Message: TCMHintShow); //message CM_HINTSHOW;
     procedure CMMouseLeave(var Message: TLMessage); message CM_MOUSELEAVE;
     procedure CMMouseWheel(var Message: TLMMouseEvent); message LM_MOUSEWHEEL;
     {$ifdef EnableNativeTVM}
@@ -2493,7 +2494,6 @@
     procedure WMGetObject(var Message: TLMessage);{ message WM_GETOBJECT;}
     {$endif}
     procedure WMHScroll(var Message: TLMHScroll); message LM_HSCROLL;
-    procedure WMKeyDown(var Message: TLMKeyDown); message LM_KEYDOWN;
     procedure WMKeyUp(var Message: TLMKeyUp); message LM_KEYUP;
     procedure WMKillFocus(var Msg: TLMKillFocus); message LM_KILLFOCUS;
     procedure WMLButtonDblClk(var Message: TLMLButtonDblClk); message LM_LBUTTONDBLCLK;
@@ -2536,6 +2536,7 @@
     procedure BeginOperation;
     function CalculateSelectionRect(X, Y: Integer): Boolean; virtual;
     function CanAutoScroll: Boolean; virtual;
+    function CanScroll(const ClientMousePos: TPoint): Boolean; virtual;
     function CanShowDragImage: Boolean; virtual;
     procedure Change(Node: PVirtualNode); virtual;
     procedure ChangeScale(M, D: Integer); override;
@@ -2761,6 +2762,7 @@
     procedure WndProc(var Message: TLMessage); override;
     procedure WriteChunks(Stream: TStream; Node: PVirtualNode); virtual;
     procedure WriteNode(Stream: TStream; Node: PVirtualNode); virtual;
+    procedure WMKeyDown(var Message: TLMKeyDown); message LM_KEYDOWN;
 
     property Alignment: TAlignment read FAlignment write SetAlignment default taLeftJustify;
     property AnimationDuration: Cardinal read FAnimationDuration write SetAnimationDuration default 200;
@@ -3008,6 +3010,7 @@
     function GetNextNoInit(Node: PVirtualNode; ConsiderChildrenAbove: Boolean = False): PVirtualNode;
     function GetNextSelected(Node: PVirtualNode; ConsiderChildrenAbove: Boolean = False): PVirtualNode;
     function GetNextSibling(Node: PVirtualNode): PVirtualNode;
+    function GetNextSiblingNoInit(Node: PVirtualNode): PVirtualNode;
     function GetNextVisible(Node: PVirtualNode; ConsiderChildrenAbove: Boolean = True): PVirtualNode;
     function GetNextVisibleNoInit(Node: PVirtualNode; ConsiderChildrenAbove: Boolean = True): PVirtualNode;
     function GetNextVisibleSibling(Node: PVirtualNode): PVirtualNode;
@@ -3026,6 +3029,7 @@
     function GetPreviousNoInit(Node: PVirtualNode; ConsiderChildrenAbove: Boolean = False): PVirtualNode;
     function GetPreviousSelected(Node: PVirtualNode; ConsiderChildrenAbove: Boolean = False): PVirtualNode;
     function GetPreviousSibling(Node: PVirtualNode): PVirtualNode;
+    function GetPreviousSiblingNoInit(Node: PVirtualNode): PVirtualNode;
     function GetPreviousVisible(Node: PVirtualNode; ConsiderChildrenAbove: Boolean = True): PVirtualNode;
     function GetPreviousVisibleNoInit(Node: PVirtualNode; ConsiderChildrenAbove: Boolean = True): PVirtualNode;
     function GetPreviousVisibleSibling(Node: PVirtualNode): PVirtualNode;
@@ -4895,7 +4899,7 @@
 function HasMMX: Boolean;
 
 // Helper method to determine whether the current processor supports MMX.
-
+{$IFDEF CPU32}
 asm
         PUSH    EBX
         XOR     EAX, EAX     // Result := False
@@ -4924,6 +4928,12 @@
 @1:
         POP     EBX
 end;
+{$ELSE}
+begin
+  //todo: should not all cpu64 have mmx?
+  Result := False;
+end;
+{$ENDIF}
 
 //----------------------------------------------------------------------------------------------------------------------
 {$ifdef EnablePrint}
@@ -8530,7 +8540,6 @@
   RequestedElements,
   ActualElements: THeaderPaintElements;
 
-  SavedDC: Integer;
   Temp: TRect;
   ColCaptionText: String;
   ColImages: TCustomImageList;
@@ -8865,9 +8874,9 @@
 
               if ActualElements <> [] then
               begin
-                SavedDC := SaveDC(Handle);
+                FHeaderBitmap.Canvas.SaveHandleState;
                 FHeader.Treeview.DoAdvancedHeaderDraw(PaintInfo, ActualElements);
-                RestoreDC(Handle, SavedDC);
+                FHeaderBitmap.Canvas.RestoreHandleState;
               end;
             end
             else // Let application draw the header.
@@ -13215,7 +13224,52 @@
 // The returned value is the number of remaining entries in the array, so the caller can reallocate (shorten)
 // the selection array if needed or -1 if nothing needs to be changed.
 
+{$IFDEF CPU64}
+label
+  PreScan, DoMainLoop, MainLoop, Skip, Finish;
 asm
+  push %rbx
+  push %rdi
+  push %rsi
+  mov %rdx, %rsi
+  mov $-1, %rdx
+  cmpq $0, %rcx
+  jz Finish
+  inc %rdx
+  mov %rsi, %rdi
+  movq $1, %rbx
+PreScan:
+  testq (%rsi), %rbx
+
+  jnz DoMainLoop
+  inc %rdx
+  add $8, %rsi
+  dec %rcx
+  jnz PreScan
+  jmp Finish
+DoMainLoop:
+  mov %rsi, %rdi
+MainLoop:
+  test (%rsi), %rbx
+  jne Skip
+  movq (%rsi), %r10
+  movq %r10, (%rdi)
+  inc %rdx
+  dec %rcx
+  jnz MainLoop
+  jmp Finish
+Skip:
+  add $8, %rsi
+  dec %rcx
+  jnz MainLoop
+Finish:
+  mov %rdx, %rax
+  pop %rsi
+  pop %rdi
+  pop %rbx
+end;
+{$ELSE}
+asm
         PUSH    EBX
         PUSH    EDI
         PUSH    ESI
@@ -13257,6 +13311,7 @@
         POP     EDI
         POP     EBX
 end;
+{$ENDIF}
 
 {$IMPLICITEXCEPTIONS ON}
 //----------------------------------------------------------------------------------------------------------------------
@@ -13869,7 +13924,7 @@
     FFocusedColumn := Value;
     if Assigned(FFocusedNode) and not (toDisableAutoscrollOnFocus in FOptions.FAutoOptions) then
     begin
-      if ScrollIntoView(FFocusedNode, toCenterScrollIntoView in FOptions.SelectionOptions, True) then
+      if ScrollIntoView(FFocusedNode, toCenterScrollIntoView in FOptions.SelectionOptions, not (toDisableAutoscrollHorizontal in FOptions.FAutoOptions)) then
         InvalidateNode(FFocusedNode);
     end;
 
@@ -14686,7 +14741,7 @@
   ShiftState: Integer;
   P: TPoint;
   Formats: TFormatArray;
-
+  Effect: LongWord;
 begin
   {$ifdef DEBUG_VTV}Logger.EnterMethod([lcDrag],'DoDragMsg');{$endif}
   S := ADragObject;
@@ -14722,7 +14777,8 @@
 
           // Allowed drop effects are simulated for VCL dd.
           Result := DROPEFFECT_MOVE or DROPEFFECT_COPY;
-          DragOver(S, ShiftState, TDragState(ADragMessage), APosition, LongWord(Result));
+          DragOver(S, ShiftState, TDragState(ADragMessage), APosition, Effect);
+          Result := LRESULT(Effect);
           FLastVCLDragTarget := FDropTargetNode;
           FVCLDragEffect := LongWord(Result);
           if (ADragMessage = dmDragLeave) and Assigned(FDropTargetNode) then
@@ -15047,7 +15103,8 @@
   LeaveStates := [tsHint];
   if [tsWheelPanning, tsWheelScrolling] * FStates = [] then
   begin
-    KillTimer(Handle, ScrollTimer);
+    if HandleAllocated then
+      KillTimer(Handle, ScrollTimer);
     LeaveStates := LeaveStates + [tsScrollPending, tsScrolling];
   end;
   DoStateChange([], LeaveStates);
@@ -15672,7 +15729,7 @@
                 if (Shift = [ssCtrlOS]) and not ActAsGrid then
                 begin
                   ScrollIntoView(Node, toCenterScrollIntoView in FOptions.SelectionOptions,
-                    not (toDisableAutoscrollOnFocus in FOptions.FAutoOptions));
+                    not (toDisableAutoscrollHorizontal in FOptions.FAutoOptions));
                   if (CharCode = VK_HOME) and not UseRightToLeftAlignment then
                     SetOffsetX(0)
                   else
@@ -17889,6 +17946,9 @@
       if (ClientWidth + FEffectiveOffsetX < Integer(FRangeX)) and (X > ClientWidth - Integer(FDefaultNodeHeight)) then
         Include(Result, sdRight);
 
+      if hoVisible in FHeader.FOptions then
+        Dec(Y, FHeader.Height);
+
       if (Y < Integer(FDefaultNodeHeight)) and (FOffsetY <> 0) then
         Include(Result, sdUp);
       if (ClientHeight - FOffsetY < Integer(FRangeY)) and (Y > ClientHeight - Integer(FDefaultNodeHeight)) then
@@ -18437,7 +18497,7 @@
 
 begin
   if Assigned(FOnDragDrop) then
-    FOnDragDrop(Self, Source, DataObject, Formats, Shift, Pt, Effect, Mode);
+    FOnDragDrop(Self, Source, {DataObject, }Formats, Shift, Pt, Effect, Mode);
 end;
 
 //----------------------------------------------------------------------------------------------------------------------
@@ -18589,7 +18649,7 @@
       InvalidateNode(FFocusedNode);
       if (FUpdateCount = 0) and not (toDisableAutoscrollOnFocus in FOptions.FAutoOptions) then
         ScrollIntoView(FFocusedNode, (toCenterScrollIntoView in FOptions.SelectionOptions) and
-          (MouseButtonDown * FStates = []), True);
+          (MouseButtonDown * FStates = []), not (toDisableAutoscrollHorizontal in FOptions.FAutoOptions));
     end;
 
     // Reset range anchor if necessary.
@@ -19395,6 +19455,8 @@
 
 begin
   GetCursorPos(P);
+  if hoVisible in FHeader.FOptions then
+    Dec(P.y, FHeader.Height);
   R := ClientRect;
   ClipRect := R;
   //todo: add MapWindowPoints to LCL??
@@ -19405,7 +19467,7 @@
   ClientP := ScreenToClient(P);
   Panning := [tsWheelPanning, tsWheelScrolling] * FStates <> [];
 
-  if IsMouseSelecting or InRect or Panning then
+  if IsMouseSelecting or InRect or Panning or CanScroll(ClientP) then
   begin
     DeltaX := 0;
     DeltaY := 0;
@@ -21122,7 +21184,7 @@
       if NewNode or NewColumn then
       begin
         ScrollIntoView(FFocusedNode, toCenterScrollIntoView in FOptions.SelectionOptions,
-                       not (toDisableAutoscrollOnFocus in FOptions.FAutoOptions));
+                       not (toDisableAutoscrollHorizontal in FOptions.FAutoOptions));
         DoFocusChange(FFocusedNode, FFocusedColumn);
       end;
     end;
@@ -21820,7 +21882,7 @@
 
 begin
   if Y < 0 then
-    Y := 0;
+    Exit(nil);
 
   AbsolutePos := Y;
   if Relative then
@@ -24358,6 +24420,12 @@
   DoCanEdit(Node, Column, Result);
 end;
 
+function TBaseVirtualTree.CanScroll(const ClientMousePos: TPoint): Boolean;
+// Determines whether auto scrolling can occur based on current mouse cursor position.
+begin
+  Result := False;
+end;
+
 //----------------------------------------------------------------------------------------------------------------------
 
 procedure TBaseVirtualTree.Clear;
@@ -26469,6 +26537,22 @@
 
 //----------------------------------------------------------------------------------------------------------------------
 
+function TBaseVirtualTree.GetNextSiblingNoInit(Node: PVirtualNode): PVirtualNode;
+
+// Returns the next sibling of Node performing no initialization.
+
+begin
+  Result := Node;
+  if Assigned(Result) then
+  begin
+    Assert(Result <> FRoot, 'Node must not be the hidden root node.');
+
+    Result := Result.NextSibling;
+  end;
+end;
+
+//----------------------------------------------------------------------------------------------------------------------
+
 function TBaseVirtualTree.GetNextVisible(Node: PVirtualNode; ConsiderChildrenAbove: Boolean = True): PVirtualNode;
 
 // Returns next node in tree, with regard to Node, which is visible.
@@ -27087,6 +27171,22 @@
 
 //----------------------------------------------------------------------------------------------------------------------
 
+function TBaseVirtualTree.GetPreviousSiblingNoInit(Node: PVirtualNode): PVirtualNode;
+
+// Get next sibling of Node, performes no initialization.
+
+begin
+  Result := Node;
+  if Assigned(Result) then
+  begin
+    Assert(Result <> FRoot, 'Node must not be the hidden root node.');
+
+    Result := Result.PrevSibling;
+  end;
+end;
+
+//----------------------------------------------------------------------------------------------------------------------
+
 function TBaseVirtualTree.GetPreviousVisible(Node: PVirtualNode; ConsiderChildrenAbove: Boolean = True): PVirtualNode;
 
 // Returns the previous node in tree, with regard to Node, which is visible.
@@ -29272,6 +29372,7 @@
   HScrollBarVisible: Boolean;
   ScrolledVertically,
   ScrolledHorizontally: Boolean;
+  OffY, OffYM: Integer;
 
 begin
   //todo: minimize calls to ClientHeight and ClientWidth
@@ -29316,7 +29417,13 @@
         if Center then
           SetOffsetY(FOffsetY - R.Bottom + ClientHeight div 2)
         else
-          SetOffsetY(FOffsetY - R.Bottom + ClientHeight);
+        begin
+          OffY  := FOffsetY - R.Bottom + ClientHeight;
+          OffYM := OffY mod DefaultNodeHeight;
+          if OffYM <> 0 then
+            OffY := OffY - (DefaultNodeHeight + OffYM);
+          SetOffsetY(OffY);
+        end;
         // When scrolling up and the horizontal scroll appears because of the operation
         // then we have to move up the node the horizontal scrollbar's height too
         // in order to avoid that the scroll bar hides the node which we wanted to have in view.
@@ -29370,10 +29477,13 @@
   end
   else
   begin
-    if ColumnRight > ClientWidth then
-      NewOffset := FEffectiveOffsetX + (ColumnRight - ClientWidth)
-    else if ColumnLeft < Header.Columns.GetVisibleFixedWidth then
-      NewOffset := FEffectiveOffsetX - (Header.Columns.GetVisibleFixedWidth - ColumnLeft);
+    if FHeader.Columns.Count > 1 then
+    begin
+      if ColumnRight > ClientWidth then
+        NewOffset := FEffectiveOffsetX + (ColumnRight - ClientWidth)
+      else if ColumnLeft < Header.Columns.GetVisibleFixedWidth then
+        NewOffset := FEffectiveOffsetX - (Header.Columns.GetVisibleFixedWidth - ColumnLeft);
+    end;
     if NewOffset <> FEffectiveOffsetX then
     begin
       if UseRightToLeftAlignment then
Index: VTGraphics.pas
===================================================================
--- VTGraphics.pas	(revision 2334)
+++ VTGraphics.pas	(working copy)
@@ -26,7 +26,27 @@
 
 implementation
 
+{$IFDEF CPU32}
 {$i vtgraphicsi.inc}
+{$ENDIF CPU32}
 
+{$IFDEF CPU64}
+
+procedure AlphaBlend(Source, Destination: HDC; const R: TRect; const Target: TPoint; Mode: TBlendMode; ConstantAlpha, Bias: Integer);
+begin
+end;
+
+function CalculateScanline(Bits: Pointer; Width, Height, Row: Integer): Pointer;
+begin
+  Result := nil;
+end;
+
+function GetBitmapBitsFromBitmap(Bitmap: HBITMAP): Pointer;
+begin
+  Result := nil;
+end;
+
+{$ENDIF CPU64}
+
 end.
 
