Index: AbArcTyp.pas
===================================================================
--- AbArcTyp.pas	(revision 512)
+++ AbArcTyp.pas	(working copy)
@@ -70,7 +70,14 @@
     function GetIsEncrypted : Boolean; virtual;
     function GetLastModFileDate : Word; virtual;
     function GetLastModFileTime : Word; virtual;
+    { This depends on in what format the attributes are stored in the archive,
+      to which system they refer (MS-DOS, Unix, etc.) and what system
+      we're running on (compile time). }
     function GetNativeFileAttributes : LongInt; virtual;
+    { This depends on in what format the date/time is stored in the archive
+      (Unix, MS-DOS, ...) and what system we're running on (compile time).
+      Returns MS-DOS local time on Windows, Unix UTC time on Unix. }
+    function GetNativeLastModFileTime : Longint; virtual;
     function GetStoredPath : string;
     function GetUncompressedSize : Int64; virtual;
     procedure SetCompressedSize(const Value : Int64); virtual;
@@ -126,6 +133,8 @@
       write SetLastModFileTime;
     property NativeFileAttributes : LongInt
       read GetNativeFileAttributes;
+    property NativeLastModFileTime : Longint
+      read GetNativeLastModFileTime;
     property StoredPath : string
       read GetStoredPath;
     property Tagged : Boolean
@@ -316,6 +325,10 @@
     procedure GetFreshenTarget(Item : TAbArchiveItem);
     function  GetItemCount : Integer;
     procedure MakeLogEntry(const FN: string; LT : TAbLogType);
+    procedure MakeFullNames(const SourceFileName: String;
+                            const ArchiveDirectory: String;
+                            out   FullSourceFileName: String;
+                            out   FullArchiveFileName: String);
     procedure ReplaceAt(Index : Integer);
     procedure SaveIfNeeded(aItem : TAbArchiveItem);
     procedure SetBaseDirectory(Value : string);
@@ -323,7 +336,16 @@
     procedure SetLogging(Value : Boolean);
 
   protected {abstract methods}
-    function CreateItem(const FileSpec : string): TAbArchiveItem;
+    function CreateItem(const SourceFileName : string;
+                        const ArchiveDirectory : string): TAbArchiveItem;
+    {SourceFileName   - full or relative path to a file/dir on some file system
+                        If full path, BaseDirectory is used to determine relative path}
+    {ArchiveDirectory - path to a directory in the archive the file/dir will be in}
+    {Example:
+      FBaseDirectory      = /dir
+      SourceFileName      = /dir/subdir/file
+      ArchiveDirectory    = files/storage  (or files/storage/)
+      -> name in archive  = files/storage/subdir/file}
       virtual; abstract;
     procedure ExtractItemAt(Index : Integer; const UseName : string);
       virtual; abstract;
@@ -384,6 +406,7 @@
       override;
     procedure Add(aItem : TAbArchiveItem);
       virtual;
+    procedure AddEntry(const Path : String; const ArchiveDirectory : String);
     procedure AddFiles(const FileMask : string; SearchAttr : Integer);
     procedure AddFilesEx(const FileMask, ExclusionMask : string;
       SearchAttr : Integer);
@@ -565,7 +588,9 @@
   AbExcept,
   AbDfBase,
   AbConst,
-  AbResString;
+  AbResString,
+  DCOSUtils,
+  DCClassesUtf8;
 
 
 { TAbArchiveItem implementation ============================================ }
@@ -647,6 +672,12 @@
   {$ENDIF}
 end;
 { -------------------------------------------------------------------------- }
+function TAbArchiveItem.GetNativeLastModFileTime : Longint;
+begin
+  LongRec(Result).Hi := LastModFileDate;
+  LongRec(Result).Lo := LastModFileTime;
+end;
+{ -------------------------------------------------------------------------- }
 function TAbArchiveItem.GetStoredPath : string;
 begin
   Result := ExtractFilePath(DiskFileName);
@@ -980,7 +1011,7 @@
   {create an archive by opening a filestream on filename with the given mode}
 begin
   FOwnsStream := True;
-  CreateFromStream(TFileStream.Create(FileName, Mode), FileName);
+  CreateFromStream(TFileStreamEx.Create(FileName, Mode), FileName);
   FMode := Mode;
 end;
 { -------------------------------------------------------------------------- }
@@ -1032,6 +1063,19 @@
   end;
 end;
 { -------------------------------------------------------------------------- }
+procedure TAbArchive.AddEntry(const Path : String; const ArchiveDirectory : String);
+var
+  Item : TAbArchiveItem;
+  FullSourceFileName, FullArchiveFileName : String;
+begin
+  MakeFullNames(Path, ArchiveDirectory, FullSourceFileName, FullArchiveFileName);
+
+  if (FullSourceFileName <> FArchiveName) then begin
+    Item := CreateItem(Path, ArchiveDirectory);
+    Add(Item);
+  end;
+end;
+{ -------------------------------------------------------------------------- }
 procedure TAbArchive.AddFiles(const FileMask : string; SearchAttr : Integer);
   {Add files to the archive where the disk filespec matches}
 begin
@@ -1043,17 +1087,15 @@
   {Add files matching Filemask except those matching ExclusionMask}
 var
   PathType : TAbPathType;
-  IsWild : Boolean;
   SaveDir : string;
   Mask : string;
   MaskF : string;
 
-  procedure CreateItems(Wild, Recursing : Boolean);
+  procedure CreateItems(Recursing : Boolean);
   var
     i : Integer;
     Files : TStrings;
     FilterList : TStringList;
-    Item : TAbArchiveItem;
   begin
     FilterList := TStringList.Create;
     try
@@ -1064,21 +1106,12 @@
         try
 
           AbFindFilesEx(Mask, SearchAttr, Files, Recursing);
-          if (Files.Count > 0) then
+          if (Files.Count > 0) then begin
             for i := 0 to pred(Files.Count) do
               if FilterList.IndexOf(Files[i]) < 0 then
-                if not Wild then begin
-                  if (Files[i] <> FArchiveName) then begin
-                    Item := CreateItem(Files[i]);
-                    Add(Item);
-                  end;
-                end else begin
-                  if (AbAddBackSlash(FBaseDirectory) + Files[i]) <> FArchiveName
-                    then begin
-                      Item := CreateItem(Files[i]);
-                      Add(Item);
-                    end;
-                end;
+                AddEntry(Files[i], Files[i]);
+            FIsDirty := true;
+          end;
         finally
           Files.Free;
         end;
@@ -1093,7 +1126,6 @@
     SearchAttr := SearchAttr and not faDirectory;
 
   CheckValid;
-  IsWild := (Pos('*', FileMask) > 0) or (Pos('?', FileMask) > 0);
   PathType := AbGetPathType(FileMask);
 
   Mask := FileMask;
@@ -1108,7 +1140,7 @@
         if BaseDirectory <> '' then
           ChDir(BaseDirectory);
         try
-          CreateItems(IsWild, soRecurse in StoreOptions);
+          CreateItems(soRecurse in StoreOptions);
         finally
           if BaseDirectory <> '' then
             ChDir(SaveDir);
@@ -1116,7 +1148,7 @@
       end;
     ptAbsolute :
       begin
-        CreateItems(IsWild, soRecurse in StoreOptions);
+        CreateItems(soRecurse in StoreOptions);
       end;
   end;
 end;
@@ -1128,7 +1160,7 @@
   Item : TAbArchiveItem;
   PT : TAbProcessType;                                               
 begin
-  Item := CreateItem(NewName);
+  Item := CreateItem('', NewName);
   CheckValid;
 
   PT := ptAdd;
@@ -1196,14 +1228,14 @@
     UseName := AbAddBackSlash(BaseDirectory) + UseName;
 
   Path := ExtractFileDir(UseName);
-  if (Path <> '') and not DirectoryExists(Path) then
+  if (Path <> '') and not mbDirectoryExists(Path) then
     if (eoCreateDirs in ExtractOptions) then
       AbCreateDirectory(Path)
     else
       raise EAbNoSuchDirectory.Create;
 
   Result := True;
-  if not Item.IsDirectory and FileExists(UseName) then
+  if not Item.IsDirectory and mbFileExists(UseName) then
     DoConfirmOverwrite(UseName, Result);
 end;
 { -------------------------------------------------------------------------- }
@@ -1560,11 +1592,12 @@
 begin
   CheckValid;
   Index := FindItem(aItem);
-  if Index <> -1 then begin
+  if Index <> -1 then
+  begin
+    FreshenAt(Index);
     {point existing item at the new file}
     if AbGetPathType(aItem.DiskFileName) = ptAbsolute then
       FItemList[Index].DiskFileName := aItem.DiskFileName;
-    FreshenAt(Index);
   end;
 end;
 { -------------------------------------------------------------------------- }
@@ -1625,7 +1658,7 @@
 { -------------------------------------------------------------------------- }
 function TAbArchive.FreshenRequired(Item : TAbArchiveItem) : Boolean;
 var
-  FS : TFileStream;
+  FS : TFileStreamEx;
   DateTime : LongInt;
   FileTime : Word;
   FileDate : Word;
@@ -1636,8 +1669,8 @@
   if BaseDirectory <> '' then
     ChDir(BaseDirectory);
   try
-    FS := TFileStream.Create(Item.DiskFileName,
-                              fmOpenRead or fmShareDenyWrite);
+    FS := TFileStreamEx.Create(Item.DiskFileName,
+                               fmOpenRead or fmShareDenyWrite);
     try
       DateTime := FileGetDate(FS.Handle);
       FileTime := LongRec(DateTime).Lo;
@@ -1761,6 +1794,45 @@
   end;
 end;
 { -------------------------------------------------------------------------- }
+procedure TAbArchive.MakeFullNames(const SourceFileName: String;
+                                   const ArchiveDirectory: String;
+                                   out   FullSourceFileName: String;
+                                   out   FullArchiveFileName: String);
+var
+  PathType : TAbPathType;
+  RelativeSourceFileName: String;
+begin
+  PathType := AbGetPathType(SourceFileName);
+  case PathType of
+    ptNone, ptRelative :
+      begin
+        if FBaseDirectory <> '' then
+          FullSourceFileName := AbAddBackSlash(FBaseDirectory) + SourceFileName
+        else
+          FullSourceFileName := SourceFileName;
+
+        RelativeSourceFileName := SourceFileName;
+      end;
+    ptAbsolute :
+      begin
+        FullSourceFileName := SourceFileName;
+
+        if FBaseDirectory <> '' then
+          RelativeSourceFileName := ExtractRelativepath(AbAddBackSlash(FBaseDirectory),
+                                                        SourceFileName)
+        else
+          RelativeSourceFileName := ExtractFileName(SourceFileName);
+      end;
+  end;
+
+  if ArchiveDirectory <> '' then
+    FullArchiveFileName := AbAddBackSlash(ArchiveDirectory) + RelativeSourceFileName
+  else
+    FullArchiveFileName := RelativeSourceFileName;
+
+  FullArchiveFileName := FixName(FullArchiveFileName);
+end;
+{ -------------------------------------------------------------------------- }
 procedure TAbArchive.Move(aItem : TAbArchiveItem; const NewStoredPath : string);
 var
   Confirm : Boolean;
@@ -1807,11 +1879,12 @@
 begin
   CheckValid;
   Index := FindItem(aItem);
-  if Index <> -1 then begin
+  if Index <> -1 then
+  begin
+    ReplaceAt(Index);
     {point existing item at the new file}
     if AbGetPathType(aItem.DiskFileName) = ptAbsolute then
       FItemList[Index].DiskFileName := aItem.DiskFileName;
-    ReplaceAt(Index);
   end;
 end;
 { -------------------------------------------------------------------------- }
@@ -1865,7 +1938,7 @@
     if Value[Length(Value)] = AbPathDelim then
       if (Length(Value) > 1) and (Value[Length(Value) - 1] <> ':') then
         System.Delete(Value, Length(Value), 1);
-  if (Length(Value) = 0) or DirectoryExists(Value) then
+  if (Length(Value) = 0) or mbDirectoryExists(Value) then
     FBaseDirectory := Value
   else
     raise EAbNoSuchDirectory.Create;
@@ -1973,7 +2046,7 @@
   Len, Offset : Integer;
 begin
   Len := SizeOf(TAbExtraSubField) + aSubField.Len;
-  Offset := PtrInt(aSubField) - PtrInt(Pointer(FBuffer));
+  Offset := Pointer(aSubField) - Pointer(FBuffer);
   if Offset + Len < Length(FBuffer) then
     Move(FBuffer[Offset + Len], aSubField^, Length(FBuffer) - Offset - Len);
   SetLength(FBuffer, Length(FBuffer) - Len);
@@ -2001,9 +2074,9 @@
   end
   else begin
     BytesLeft := Length(FBuffer) -
-      Integer(PtrInt(aCurField) - PtrInt(Pointer(FBuffer))) -
+      (Pointer(aCurField) - Pointer(FBuffer)) -
       SizeOf(TAbExtraSubField) - aCurField.Len;
-    aCurField := Pointer(PtrInt(aCurField) + aCurField.Len + SizeOf(TAbExtraSubField));
+    Inc(Pointer(aCurField), aCurField.Len + SizeOf(TAbExtraSubField));
   end;
   Result := (BytesLeft >= SizeOf(TAbExtraSubField));
   if Result and (BytesLeft < SizeOf(TAbExtraSubField) + aCurField.Len) then
Index: AbBitBkt.pas
===================================================================
--- AbBitBkt.pas	(revision 512)
+++ AbBitBkt.pas	(working copy)
@@ -47,7 +47,7 @@
       FBufPosn : longint;
       FPosn    : Int64;
       FSize    : Int64;
-      FTail    : longint;
+      FTail    : Int64;
     protected
     public
       constructor Create(aBufSize : cardinal);
@@ -108,8 +108,8 @@
 {--------}
 function TAbBitBucketStream.Read(var Buffer; Count : Longint) : Longint;
 var
-  Chunk2Size : longint;
-  Chunk1Size : longint;
+  Chunk2Size : Int64;
+  Chunk1Size : Int64;
   OutBuffer  : PByte;
 begin
   OutBuffer := @Buffer;
@@ -146,7 +146,7 @@
   end;
   if (Chunk2Size > 0) then begin
     {we've wrapped}
-    Move(FBuffer[0], PByte(PtrInt(OutBuffer) + PtrInt(Chunk1Size))^, Chunk2Size);
+    Move(FBuffer[0], (OutBuffer + Chunk1Size)^, Chunk2Size);
     FBufPosn := Chunk2Size;
     inc(FPosn, Chunk2Size);
   end;
@@ -155,8 +155,8 @@
 {--------}
 function TAbBitBucketStream.Write(const Buffer; Count : Longint) : Longint;
 var
-  Chunk2Size : longint;
-  Chunk1Size : longint;
+  Chunk2Size : Int64;
+  Chunk1Size : Int64;
   InBuffer   : PByte;
   Overage    : longint;
 begin
@@ -186,7 +186,7 @@
   {if the second chunk size is not zero, write the second chunk; note
    that we have wrapped}
   if (Chunk2Size > 0) then begin
-    Move(PByte(PtrInt(InBuffer) + PtrInt(Chunk1Size))^, FBuffer[0], Chunk2Size);
+    Move((InBuffer + Chunk1Size)^, FBuffer[0], Chunk2Size);
     FTail := Chunk2Size;
   end;
   {the stream size and position have changed}
Index: AbBrowse.pas
===================================================================
--- AbBrowse.pas	(revision 512)
+++ AbBrowse.pas	(working copy)
@@ -220,13 +220,15 @@
 uses
   SysUtils,
   AbExcept,
-{$IFDEF MSWINDOWS}
+{$IF DEFINED(ExtractCabSupport)}
   AbCabTyp,
 {$ENDIF}
   AbZipTyp,
   AbTarTyp,
   AbGzTyp,
-  AbBzip2Typ;
+  AbBzip2Typ,
+  DCOSUtils,
+  DCClassesUtf8;
 
 { TAbBaseBrowser implementation ======================================= }
 
@@ -515,68 +517,52 @@
 function AbDetermineArcType(const FN : string; AssertType : TAbArchiveType) : TAbArchiveType;
 var
   Ext : string;
-  FS : TFileStream;
+  FS : TStream = nil;
 begin
   Result := AssertType;
-  if Result = atUnknown then begin
+  { Guess archive type based on it's content }
+  if (Result = atUnknown) and mbFileExists(FN) and (AbFileGetSize(FN) > 0) then
+    try
+      FS := TFileStreamEx.Create(FN, fmOpenRead or fmShareDenyNone);
+      Result := VerifyZip(FS);
+      if Result = atUnknown then
+        Result := VerifySelfExtracting(FS);
+      if Result = atUnknown then
+        Result := VerifyTar(FS);
+      if Result = atUnknown then
+        Result := VerifyGzip(FS);
+      {$IF DEFINED(ExtractCabSupport)}
+      if Result = atUnknown then
+        Result := VerifyCab(FS);
+      {$ENDIF}
+      if Result = atUnknown then
+        Result := VerifyBzip2(FS);
+    finally
+      if Assigned(FS) then
+        FreeAndNil(FS);
+    end
+  else if Result = atUnknown then begin
     { Guess archive type based on it's extension }
     Ext := UpperCase(ExtractFileExt(FN));
     if (Ext = '.ZIP') or (Ext = '.JAR') then
-      Result := atZip;
-    if (Ext = '.EXE') then
-      Result := atSelfExtZip;
-    if (Ext = '.TAR') then
-      Result := atTar;
-    if (Ext = '.GZ') then
-      Result := atGzip;
-    if (Ext = '.TGZ') then
-      Result := atGzippedTar;
-    if (Ext = '.CAB') then
-      Result := atCab;
-    if (Ext = '.BZ2') then
-      Result := atBzip2;
-    if (Ext = '.TBZ') then
+      Result := atZip
+    else if (Ext = '.TAR') then
+      Result := atTar
+    else if (Ext = '.GZ') then
+      Result := atGzip
+    else if (Ext = '.TGZ') then
+      Result := atGzippedTar
+    else if (Ext = '.CAB') then
+      Result := atCab
+    else if (Ext = '.BZ2') then
+      Result := atBzip2
+    else if (Ext = '.TBZ') then
       Result := atBzippedTar;
   end;
-  {$IFNDEF MSWINDOWS}
+  {$IF NOT DEFINED(ExtractCabSupport)}
   if Result = atCab then
     Result := atUnknown;
   {$ENDIF}
-  if FileExists(FN) and (AbFileGetSize(FN) > 0) then begin
-    { If the file doesn't exist (or is empty) presume to make one, otherwise
-      guess or verify the contents }
-    FS := TFileStream.Create(FN, fmOpenRead or fmShareDenyNone);
-    try
-      if Result = atUnknown then
-        Result := AbDetermineArcType(FS)
-      else begin
-        case Result of
-          atZip : begin
-            Result := VerifyZip(FS);
-          end;
-          atSelfExtZip : begin
-            Result := VerifySelfExtracting(FS);
-          end;
-          atTar : begin
-            Result := VerifyTar(FS);
-          end;
-          atGzip, atGzippedTar: begin
-            Result := VerifyGzip(FS);
-          end;
-          {$IFDEF MSWINDOWS}
-          atCab : begin
-            Result := VerifyCab(FS);
-          end;
-          {$ENDIF}
-          atBzip2, atBzippedTar: begin
-            Result := VerifyBzip2(FS);
-          end;
-        end;
-      end;
-    finally
-      FS.Free;
-    end;
-  end;
 end;
 { -------------------------------------------------------------------------- }
 function AbDetermineArcType(aStream: TStream): TAbArchiveType;
@@ -591,7 +577,7 @@
     Result := VerifyGzip(aStream);
   if Result = atUnknown then
     Result := VerifyBzip2(aStream);
-  {$IFDEF MSWINDOWS}
+  {$IF DEFINED(ExtractCabSupport)}
   if Result = atUnknown then
     Result := VerifyCab(aStream);
   {$ENDIF}
Index: AbBzip2.pas
===================================================================
--- AbBzip2.pas	(revision 512)
+++ AbBzip2.pas	(working copy)
@@ -391,7 +391,7 @@
 {$ENDIF}
 
 const
-  libbz2 = {$IF DEFINED(MSWINDOWS)}'libbz2.dll'
+  libbz2 = {$IF DEFINED(MSWINDOWS)}'bz2.dll'
            {$ELSEIF DEFINED(DARWIN)}'libbz2.dylib'
            {$ELSE}'libbz2.so.1'{$IFEND};
 
@@ -527,8 +527,7 @@
         P := OutBuf;
         Inc(OutBytes, 256);
         ReallocMem(OutBuf, OutBytes);
-        strm.next_out := PByte(PtrInt(OutBuf)
-             + (PtrInt(strm.next_out) - PtrInt(P)));
+        strm.next_out := OutBuf + (strm.next_out - P);
         strm.avail_out := 256;
       end;
     finally
@@ -571,7 +570,7 @@
         P := OutBuf;
         Inc(OutBytes, BufInc);
         ReallocMem(OutBuf, OutBytes);
-        strm.next_out := PByte(PtrInt(OutBuf) + (PtrInt(strm.next_out) - PtrInt(P)));
+        strm.next_out := OutBuf + (strm.next_out - P);
         strm.avail_out := BufInc;
       end;
     finally
Index: AbBzip2Typ.pas
===================================================================
--- AbBzip2Typ.pas	(revision 512)
+++ AbBzip2Typ.pas	(working copy)
@@ -86,7 +86,8 @@
 
   protected
     { Inherited Abstract functions }
-    function CreateItem(const FileSpec : string): TAbArchiveItem; override;
+    function CreateItem(const SourceFileName   : string;
+                        const ArchiveDirectory : string): TAbArchiveItem; override;
     procedure ExtractItemAt(Index : Integer; const NewName : string); override;
     procedure ExtractItemToStreamAt(Index : Integer; aStream : TStream); override;
     procedure LoadArchive; override;
@@ -118,7 +119,7 @@
   Windows, // Fix inline warnings
 {$ENDIF}
   StrUtils, SysUtils,
-  AbBzip2, AbExcept, AbVMStrm, AbBitBkt;
+  AbBzip2, AbExcept, AbVMStrm, AbBitBkt, DCOSUtils, DCClassesUtf8;
 
 { ****************** Helper functions Not from Classes Above ***************** }
 function VerifyHeader(const Header : TAbBzip2Header) : Boolean;
@@ -193,20 +194,29 @@
   FState    := gsBzip2;
 end;
 { -------------------------------------------------------------------------- }
-function TAbBzip2Archive.CreateItem(const FileSpec: string): TAbArchiveItem;
+function TAbBzip2Archive.CreateItem(const SourceFileName   : string;
+                                    const ArchiveDirectory : string): TAbArchiveItem;
+var
+  Bz2Item : TAbBzip2Item;
+  FullSourceFileName, FullArchiveFileName: String;
 begin
   if IsBzippedTar and TarAutoHandle then begin
     SwapToTar;
-    Result := inherited CreateItem(FileSpec);
+    Result := inherited CreateItem(SourceFileName, ArchiveDirectory);
   end
   else begin
     SwapToBzip2;
-    Result := TAbBzip2Item.Create;
+    Bz2Item := TAbBzip2Item.Create;
     try
-      Result.DiskFileName := ExpandFileName(FileSpec);
-      Result.FileName := FixName(FileSpec);
+      MakeFullNames(SourceFileName, ArchiveDirectory,
+                    FullSourceFileName, FullArchiveFileName);
+
+      Bz2Item.FileName := FullArchiveFileName;
+      Bz2Item.DiskFileName := FullSourceFileName;
+
+      Result := Bz2Item;
     except
-      Result.Free;
+      Result := nil;
       raise;
     end;
   end;
@@ -223,7 +233,7 @@
 procedure TAbBzip2Archive.ExtractItemAt(Index: Integer;
   const NewName: string);
 var
-  OutStream : TFileStream;
+  OutStream : TStream;
 begin
   if IsBzippedTar and TarAutoHandle then begin
     SwapToTar;
@@ -231,7 +241,7 @@
   end
   else begin
     SwapToBzip2;
-    OutStream := TFileStream.Create(NewName, fmCreate or fmShareDenyNone);
+    OutStream := TFileStreamEx.Create(NewName, fmCreate or fmShareDenyNone);
     try
       try
         ExtractItemToStreamAt(Index, OutStream);
@@ -242,12 +252,12 @@
     except
       on E : EAbUserAbort do begin
         FStatus := asInvalid;
-        if FileExists(NewName) then
-          DeleteFile(NewName);
+        if mbFileExists(NewName) then
+          mbDeleteFile(NewName);
         raise;
       end else begin
-        if FileExists(NewName) then
-          DeleteFile(NewName);
+        if mbFileExists(NewName) then
+          mbDeleteFile(NewName);
         raise;
       end;
     end;
@@ -347,7 +357,7 @@
             if CurItem.Action = aaStreamAdd then
               CompStream.CopyFrom(InStream, 0){ Copy/compress entire Instream to FBzip2Stream }
             else begin
-              InputFileStream := TFileStream.Create(CurItem.DiskFileName, fmOpenRead or fmShareDenyWrite );
+              InputFileStream := TFileStreamEx.Create(CurItem.DiskFileName, fmOpenRead or fmShareDenyWrite );
               try
                 CompStream.CopyFrom(InputFileStream, 0);{ Copy/compress entire Instream to FBzip2Stream }
               finally
Index: AbDfInW.pas
===================================================================
--- AbDfInW.pas	(revision 512)
+++ AbDfInW.pas	(working copy)
@@ -261,8 +261,7 @@
     HashInx :=
        ((HashInx shl c_HashShift) xor longint(CurPos[2])) and
        c_HashMask;
-    HashChains^[longint(CurPos) and FWinMask] :=
-       HashHeads^[HashInx];
+    HashChains^[PtrUInt(CurPos) and FWinMask] := HashHeads^[HashInx];
     HashHeads^[HashInx] := CurPos;
     inc(CurPos);
   end;
@@ -367,7 +366,6 @@
   {$ENDIF}
 {$ENDIF}
 type
-  PLongint = ^longint;
   PWord    = ^word;
 var
   MaxLen     : longint;
@@ -406,7 +404,7 @@
 
   {update the chain itself: set the entry for this position equal to
    the previous string position}
-  FHashChains^[longint(CurPos) and FWinMask] := PrevStrPos;
+  FHashChains^[PtrUInt(CurPos) and FWinMask] := PrevStrPos;
 
   {calculate the maximum match we could do at this position}
   MaxMatch := (FLookAheadEnd - CurPos);
@@ -602,7 +600,7 @@
       Break;
 
     {otherwise move onto the next position}
-    PrevStrPos := FHashChains^[longint(PrevStrPos) and FWinMask];
+    PrevStrPos := FHashChains^[PtrUInt(PrevStrPos) and FWinMask];
   end;
   {$ENDIF}
 
@@ -700,13 +698,11 @@
 end;
 {--------}
 procedure TAbDfInputWindow.iwSlide;
-type
-  PLongint = ^longint;
 var
   i : integer;
-  ByteCount : integer;
-  Buffer    : longint;
-  ListItem  : PLongint;
+  ByteCount : PtrInt;
+  Buffer    : PAnsiChar;
+  ListItem  : PPointer;
 begin
   {move current valid data back to the start of the buffer}
   ByteCount := FLookAheadEnd - FStart;
@@ -719,22 +715,22 @@
   dec(FLookAheadEnd, ByteCount);
 
   {patch up the hash table: the head pointers}
-  Buffer := longint(FBuffer);
-  ListItem := PLongint(@FHashHeads^[0]);
+  Buffer := FBuffer;
+  ListItem := @FHashHeads^[0];
   for i := 0 to pred(c_HashCount) do begin
     dec(ListItem^, ByteCount);
     if (ListItem^ < Buffer) then
-      ListItem^ := 0;
-    inc(PAnsiChar(ListItem), sizeof(pointer));
+      ListItem^ := nil;
+    inc(ListItem);
   end;
 
   {..the chain pointers}
-  ListItem  := PLongint(@FHashChains^[0]);
+  ListItem  := @FHashChains^[0];
   for i := 0 to pred(FWinSize) do begin
     dec(ListItem^, ByteCount);
     if (ListItem^ < Buffer) then
-      ListItem^ := 0;
-    inc(PAnsiChar(ListItem), sizeof(pointer));
+      ListItem^ := nil;
+    inc(ListItem);
   end;
 
   {now read some more data from the stream}
Index: AbDfStrm.pas
===================================================================
--- AbDfStrm.pas	(revision 512)
+++ AbDfStrm.pas	(working copy)
@@ -230,7 +230,8 @@
   {save the on progress handler}
   if Assigned(aOnProgress) and (aStreamSize > 0) then begin
     FOnProgress := aOnProgress;
-    FStreamSize := aStreamSize;
+    //FStreamSize := aStreamSize;
+    FStreamSize := aStream.Size - aStream.Position;
   end;
 end;
 {--------}
Index: AbGzTyp.pas
===================================================================
--- AbGzTyp.pas	(revision 512)
+++ AbGzTyp.pas	(working copy)
@@ -140,6 +140,7 @@
     function GetLastModFileDate : Word; override;
     function GetLastModFileTime : Word; override;
     function GetLastModTimeAsDateTime: TDateTime; override;
+    function GetNativeLastModFileTime: Longint; override;
 
     procedure SetExternalFileAttributes( Value : LongWord ); override;
     procedure SetFileName(const Value : string); override;
@@ -242,7 +243,8 @@
     procedure SwapToTar;
 
   protected
-    function CreateItem(const FileSpec : string): TAbArchiveItem;
+    function CreateItem(const SourceFileName   : string;
+                        const ArchiveDirectory : string): TAbArchiveItem;
       override;
     procedure ExtractItemAt(Index : Integer; const UseName : string);
       override;
@@ -291,7 +293,8 @@
   Windows,
   {$ENDIF}
   SysUtils,
-  AbBitBkt, AbCharset, AbDfBase, AbDfDec, AbDfEnc, AbExcept, AbResString, AbVMStrm;
+  AbBitBkt, AbDfBase, AbDfDec, AbDfEnc, AbExcept, AbResString,
+  AbVMStrm, DCOSUtils, DCClassesUtf8, DCConvertEncoding;
 
 const
   { Header Signature Values}
@@ -708,6 +711,20 @@
   Result := AbUnixTimeToLocalDateTime(FGZHeader.ModTime);
 end;
 
+function TAbGzipItem.GetNativeLastModFileTime: Longint;
+{$IFDEF MSWINDOWS}
+var
+  DateTime: TDateTime;
+{$ENDIF}
+begin
+  Result   := FGZHeader.ModTime;
+
+{$IFDEF MSWINDOWS}
+  DateTime := AbUnixTimeToLocalDateTime(Result);
+  Result   := AbDateTimeToDosFileDate(DateTime);
+{$ENDIF}
+end;
+
 procedure TAbGzipItem.LoadGzHeaderFromStream(AStream: TStream);
 var
   LenW : Word;
@@ -731,7 +748,7 @@
   { Get Filename, if any }
   if HasFileName then begin
     FRawFileName := ReadCStringInStream(AStream);
-    FFileName := AbRawBytesToString(FRawFileName)
+    FFileName := CeRawToUtf8(FRawFileName)
   end
   else
     FFileName := 'unknown';
@@ -804,7 +821,7 @@
 procedure TAbGzipItem.SetFileName(const Value: string);
 begin
   FFileName := Value;
-  FRawFileName := AbStringToUnixBytes(Value);
+  FRawFileName := CeUtf8ToSys(Value);
   if Value <> '' then
     FGzHeader.Flags := FGzHeader.Flags or AB_GZ_FLAG_FNAME
   else
@@ -886,25 +903,30 @@
   FState := gsGzip;
 end;
 
-function TAbGzipArchive.CreateItem(const FileSpec: string): TAbArchiveItem;
+function TAbGzipArchive.CreateItem(const SourceFileName   : string;
+                                   const ArchiveDirectory : string): TAbArchiveItem;
 var
   GzItem : TAbGzipItem;
+  FullSourceFileName, FullArchiveFileName: String;
 begin
   if IsGZippedTar and TarAutoHandle then begin
     SwapToTar;
-    Result := inherited CreateItem(FileSpec);
+    Result := inherited CreateItem(SourceFileName, ArchiveDirectory);
   end
   else begin
     SwapToGzip;
     GzItem := TAbGzipItem.Create;
     try
-      GzItem.CompressedSize := 0;
-      GzItem.CRC32 := 0;
-      GzItem.DiskFileName := ExpandFileName(FileSpec);
-      GzItem.FileName := FixName(FileSpec);
+      MakeFullNames(SourceFileName, ArchiveDirectory,
+                    FullSourceFileName, FullArchiveFileName);
+
+      GzItem.FileName := FullArchiveFileName;
+      GzItem.DiskFileName := FullSourceFileName;
+
       Result := GzItem;
     except
       Result := nil;
+      raise;
     end;
   end;
 end;
@@ -921,7 +943,7 @@
 procedure TAbGzipArchive.ExtractItemAt(Index: Integer;
   const UseName: string);
 var
-  OutStream : TFileStream;
+  OutStream : TStream;
   CurItem : TAbGzipItem;
 begin
   if IsGZippedTar and TarAutoHandle then begin
@@ -934,7 +956,7 @@
 
     CurItem := TAbGzipItem(ItemList[Index]);
 
-    OutStream := TFileStream.Create(UseName, fmCreate or fmShareDenyNone);
+    OutStream := TFileStreamEx.Create(UseName, fmCreate or fmShareDenyNone);
     try
       try {OutStream}
         ExtractItemToStreamAt(Index, OutStream);
@@ -946,12 +968,12 @@
     except
       on E : EAbUserAbort do begin
         FStatus := asInvalid;
-        if FileExists(UseName) then
-          DeleteFile(UseName);
+        if mbFileExists(UseName) then
+          mbDeleteFile(UseName);
         raise;
       end else begin
-        if FileExists(UseName) then
-          DeleteFile(UseName);
+        if mbFileExists(UseName) then
+          mbDeleteFile(UseName);
         raise;
       end;
     end;
@@ -1089,7 +1111,6 @@
   i                   : Integer;
   NewStream           : TAbVirtualMemoryStream;
   UncompressedStream  : TStream;
-  SaveDir             : string;
   CurItem             : TAbGzipItem;
 begin
   {prepare for the try..finally}
@@ -1154,17 +1175,9 @@
                   OutGzHelp.WriteArchiveTail;
                 end
                 else begin
-                { it's coming from a file }
-                  GetDir(0, SaveDir);
-                  try {SaveDir}
-                    if (BaseDirectory <> '') then
-                      ChDir(BaseDirectory);
-                    CurItem.LastModTimeAsDateTime := AbGetFileTime(CurItem.DiskFileName);
-                    UncompressedStream := TFileStream.Create(CurItem.DiskFileName,
+                  CurItem.LastModTimeAsDateTime := AbGetFileTime(CurItem.DiskFileName);
+                  UncompressedStream := TFileStreamEx.Create(CurItem.DiskFileName,
                       fmOpenRead or fmShareDenyWrite );
-                  finally {SaveDir}
-                    ChDir( SaveDir );
-                  end; {SaveDir}
 
                   try
                     CurItem.UncompressedSize := UncompressedStream.Size;
@@ -1197,7 +1210,7 @@
       { need new stream to write }
       FreeAndNil(FStream);
       FGZStream := nil;
-      FStream := TFileStream.Create(FArchiveName, fmCreate or fmShareDenyWrite);
+      FStream := TFileStreamEx.Create(FArchiveName, fmCreate or fmShareDenyWrite);
       FGZStream := FStream;
       FStream.CopyFrom(NewStream, NewStream.Size);
     end;
Index: AbSelfEx.pas
===================================================================
--- AbSelfEx.pas	(revision 512)
+++ AbSelfEx.pas	(working copy)
@@ -49,9 +49,9 @@
     FStubExe      : string;
     FZipFile      : string;
     FSelfExe      : string;
-    FStubStream   : TFileStream;
-    FZipStream    : TFileStream;
-    FSelfStream    : TFileStream;
+    FStubStream   : TStream;
+    FZipStream    : TStream;
+    FSelfStream    : TStream;
     FOnGetStubExe : TAbGetFileEvent;
     FOnGetZipFile : TAbGetFileEvent;
 
@@ -88,7 +88,7 @@
 {$IFDEF LibcAPI}
   Libc,
 {$ENDIF}
-  AbExcept, AbZipTyp;
+  AbExcept, AbZipTyp, DCOSUtils, DCClassesUtf8;
 
 { -------------------------------------------------------------------------- }
 function TAbMakeSelfExe.Execute : Boolean;
@@ -100,20 +100,20 @@
     DoGetStubExe(Abort);
   if Abort then
     raise EAbUserAbort.Create;
-  if not FileExists(FStubExe) then
+  if not mbFileExists(FStubExe) then
     raise EAbFileNotFound.Create;
   if (FZipFile = '') then
     DoGetZipFile(Abort);
   if Abort then
     raise EAbUserAbort.Create;
-  if not FileExists(FZipFile) then
+  if not mbFileExists(FZipFile) then
     raise EAbFileNotFound.Create;
 
-  FStubStream := TFileStream.Create(FStubExe, fmOpenRead or fmShareDenyWrite);
-  FZipStream := TFileStream.Create(FZipFile, fmOpenRead or fmShareDenyWrite);
+  FStubStream := TFileStreamEx.Create(FStubExe, fmOpenRead or fmShareDenyWrite);
+  FZipStream := TFileStreamEx.Create(FZipFile, fmOpenRead or fmShareDenyWrite);
   if (FSelfExe = '') then
     FSelfExe := ChangeFileExt(FZipFile, '.exe');
-  FSelfStream := TFileStream.Create(FSelfExe, fmCreate or fmShareExclusive);
+  FSelfStream := TFileStreamEx.Create(FSelfExe, fmCreate or fmShareExclusive);
   try
     MakeSelfExtracting(FStubStream, FZipStream, FSelfStream);
     Result := True;
Index: AbSpanSt.pas
===================================================================
--- AbSpanSt.pas	(revision 512)
+++ AbSpanSt.pas	(working copy)
@@ -142,7 +142,7 @@
 {$IFDEF MSWINDOWS}
   Windows,
 {$ENDIF}
-  Math, RTLConsts, SysUtils, AbUtils, AbExcept;
+  Math, RTLConsts, SysUtils, AbUtils, AbExcept, DCOSUtils, DCClassesUtf8;
 
 
 {============================================================================}
@@ -181,7 +181,7 @@
 begin
   inherited Create(ArchiveName);
   FCurrentImage := CurrentImage;
-  FIsSplit := FileExists(GetImageName(1)) or not AbDriveIsRemovable(ArchiveName);
+  FIsSplit := mbFileExists(GetImageName(1)) or not AbDriveIsRemovable(ArchiveName);
   FLastImage := CurrentImage;
   FStream := Stream;
 end;
@@ -218,7 +218,7 @@
   end
   else
     raise EAbUserAbort.Create;
-  FStream := TFileStream.Create(ImageName, fmOpenRead or fmShareDenyWrite);
+  FStream := TFileStreamEx.Create(ImageName, fmOpenRead or fmShareDenyWrite);
 end;
 {------------------------------------------------------------------------------}
 function TAbSpanReadStream.Read(var Buffer; Count: Longint): Longint;
@@ -273,7 +273,7 @@
 procedure TAbSpanReadStream.SetOnRequestImage(Value: TAbRequestImageEvent);
 begin
   FOnRequestImage := Value;
-  FIsSplit := FileExists(GetImageName(1)) or not AbDriveIsRemovable(FArchiveName);
+  FIsSplit := mbFileExists(GetImageName(1)) or not AbDriveIsRemovable(FArchiveName);
 end;
 
 {============================================================================}
@@ -302,7 +302,7 @@
   FreeAndNil(FStream);
   Inc(FCurrentImage);
   if FThreshold > 0 then
-    RenameFile(FArchiveName, GetImageName(FCurrentImage))
+    mbRenameFile(FArchiveName, GetImageName(FCurrentImage))
   else begin
     if Assigned(FOnRequestBlankDisk) then begin
       Abort := False;
@@ -316,7 +316,7 @@
       raise EAbUserAbort.Create;
     AbSetSpanVolumeLabel(AbDrive(FArchiveName), FCurrentImage);
   end;
-  FStream := TFileStream.Create(FArchiveName, fmCreate or fmShareDenyWrite);
+  FStream := TFileStreamEx.Create(FArchiveName, fmCreate or fmShareDenyWrite);
   FImageSize := 0;
 end;
 {------------------------------------------------------------------------------}
Index: AbTarTyp.pas
===================================================================
--- AbTarTyp.pas	(revision 512)
+++ AbTarTyp.pas	(working copy)
@@ -320,6 +320,7 @@
     function GetLastModFileTime : Word; override;
     function GetLastModTimeAsDateTime: TDateTime; override;
     function GetNativeFileAttributes : LongInt; override;
+    function GetNativeLastModFileTime: Longint; override;
     function GetUncompressedSize : Int64; override;
 
     procedure SetCompressedSize(const Value : Int64); override;       { Extended Headers }
@@ -418,7 +419,8 @@
     FArchReadOnly : Boolean;
     FArchFormat: TAbTarHeaderFormat;
   protected
-    function CreateItem(const FileSpec : string): TAbArchiveItem;
+    function CreateItem(const SourceFileName   : string;
+                        const ArchiveDirectory : string): TAbArchiveItem;
       override;
     procedure ExtractItemAt(Index : Integer; const UseName : string);
       override;
@@ -457,7 +459,8 @@
   {$IFDEF MSWINDOWS}
   Windows, // Fix inline warnings
   {$ENDIF MSWINDOWS}
-  Math, RTLConsts, SysUtils, AbCharset, AbVMStrm, AbExcept;
+  Math, RTLConsts, SysUtils, AbVMStrm, AbExcept,
+  DCOSUtils, DCClassesUtf8, DCConvertEncoding;
 
 { ****************** Helper functions Not from Classes Above ***************** }
 function OctalToInt(const Oct : PAnsiChar; aLen : integer): Int64;
@@ -678,6 +681,19 @@
   Result := AbUnixTimeToLocalDateTime(FTarItem.ModTime);
 end;
 
+function TAbTarItem.GetNativeLastModFileTime: Longint;
+{$IFDEF MSWINDOWS}
+var
+  DateTime: TDateTime;
+{$ENDIF}
+begin
+  Result   := Self.ModTime;
+
+{$IFDEF MSWINDOWS}
+  DateTime := AbUnixTimeToLocalDateTime(Result);
+  Result   := AbDateTimeToDosFileDate(DateTime);
+{$ENDIF}
+end;
 function TAbTarItem.GetLinkName: string;
 begin
   Result := FTarItem.LinkName;
@@ -819,7 +835,7 @@
       RawFileName := PTarHeader.Name;
   end; { End not FoundName }
 
-  FTarItem.Name := AbRawBytesToString(RawFileName);
+  FTarItem.Name := CeRawToUtf8(RawFileName);
 end;
 
 { Extract the file name from the headers }
@@ -876,7 +892,7 @@
   if not FoundName then
     RawLinkName := PHeader.LinkName;
 
-  FTarItem.LinkName := AbRawBytesToString(RawLinkName);
+  FTarItem.LinkName := CeRawToUtf8(RawLinkName);
 end;
 
 { Return True if CheckSum passes out. }
@@ -1017,8 +1033,8 @@
   begin
     ParseTarHeaders; { Update FTarItem values }
     FFileName := FTarItem.Name; {FTarHeader.Name;}
-    FDiskFileName := FileName;
-    AbUnfixName(FDiskFileName);
+//  FDiskFileName := FileName;
+//  AbUnfixName(FDiskFileName);
   end;
   Action := aaNone;
   Tagged := False;
@@ -1333,7 +1349,7 @@
          OLD_GNU & GNU: Add N Headers for name, Update name in MD header, update name field in File Headers, min 3 headers
 
       Add headers to length of new Name Length, update name in file header, update name fields }
-  RawFileName := AbStringToUnixBytes(Value);
+  RawFileName := CeUtf8ToSys(Value);
   { In all cases zero out the name fields in the File Header. }
   if Length(RawFileName) > AB_TAR_NAMESIZE then begin { Must be null terminated except at 100 char length }
     { Look for long name meta-data headers already in the archive. }
@@ -1431,8 +1447,8 @@
 
   { Update the inherited file names. }
   FFileName := FTarItem.Name;
-  DiskFileName := FFileName;
-  AbUnfixName(FDiskFileName);
+//DiskFileName := FFileName;
+//AbUnfixName(FDiskFileName); // Don't override DiskFileName
   FTarItem.Dirty := True;
 end;
 
@@ -1527,7 +1543,7 @@
       if old was Long,
          OLD_GNU & GNU: Add N Headers for name, Update name in MD header, update name field in File Headers, min 3 headers
       STAR & PAX: And should not yet get here.}
-  RawLinkName := AbStringToUnixBytes(Value);
+  RawLinkName := CeUtf8ToSys(Value);
   if Length(RawLinkName) > AB_TAR_NAMESIZE then { Must be null terminated except at 100 char length }
   begin
     { Look for long name meta-data headers already in the archive. }
@@ -1838,16 +1854,19 @@
   FArchFormat := V7_FORMAT;  // Default for new archives
 end;
 
-function TAbTarArchive.CreateItem(const FileSpec: string): TAbArchiveItem;
+function TAbTarArchive.CreateItem(const SourceFileName   : string;
+                                  const ArchiveDirectory : string): TAbArchiveItem;
 var
   Item : TAbTarItem;
-  S : String;
   I: Integer;
+  FullSourceFileName, FullArchiveFileName: String;
 begin
   if FArchReadOnly then
     raise EAbTarBadOp.Create; { Create Item Unsupported in this Archive }
 
-  S := FixName(FileSpec);
+  MakeFullNames(SourceFileName, ArchiveDirectory,
+                FullSourceFileName, FullArchiveFileName);
+
   Item := TAbTarItem.Create;
   try
   //  HeaderFormat = (UNKNOWN_FORMAT, V7_FORMAT, OLDGNU_FORMAT, GNU_FORMAT, USTAR_FORMAT, STAR_FORMAT, POSIX_FORMAT);
@@ -1863,7 +1882,7 @@
       Item.LinkFlag := AB_TAR_LF_NORMAL;
       Item.Magic := AB_TAR_MAGIC_VAL+AB_TAR_MAGIC_VER;
     end
-    else if (FArchFormat = V7_FORMAT) and (Length(S) > 100) then
+    else if (FArchFormat = V7_FORMAT) and (Length(FullArchiveFileName) > 100) then
       begin { Switch the rep over to GNU so it can have long file names. }
       FArchFormat := OLDGNU_FORMAT;
       Item.ArchiveFormat := OLDGNU_FORMAT;
@@ -1882,9 +1901,10 @@
 
     { Most others are initialized in the .Create }
     Item.CRC32 := 0;
+
     { Note this can raise exceptions for file name lengths. }
-    Item.FileName := FixName(FileSpec);
-    Item.DiskFileName := ExpandFileName(FileSpec);
+    Item.FileName := FullArchiveFileName;
+    Item.DiskFileName := FullSourceFileName;
     Item.Action := aaNone;
   finally
     Result := Item;
@@ -1894,7 +1914,7 @@
 
 procedure TAbTarArchive.ExtractItemAt(Index: Integer; const UseName: string);
 var
-  OutStream : TFileStream;
+  OutStream : TStream;
   CurItem : TAbTarItem;
 begin
   { Check the index is not out of range. }
@@ -1914,7 +1934,7 @@
   if CurItem.IsDirectory then
     AbCreateDirectory(UseName)
   else begin
-    OutStream := TFileStream.Create(UseName, fmCreate or fmShareDenyNone);
+    OutStream := TFileStreamEx.Create(UseName, fmCreate or fmShareDenyNone);
     try
       try {OutStream}
         ExtractItemToStreamAt(Index, OutStream);
@@ -1924,7 +1944,7 @@
     except
       if ExceptObject is EAbUserAbort then
         FStatus := asInvalid;
-      DeleteFile(UseName);
+      mbDeleteFile(UseName);
       raise;
     end;
   end;
@@ -2060,7 +2080,7 @@
     AbStripDrive( lValue );
 
   { check for a leading slash }
-  if lValue[1] = AbPathDelim then
+  if (Length(lValue) > 0) and (lValue[1] = AbPathDelim) then
     System.Delete( lValue, 1, 1 );
 
   if soStripPath in StoreOptions then
@@ -2097,7 +2117,6 @@
   i              : Integer;
   NewStream      : TAbVirtualMemoryStream;
   TempStream     : TStream;
-  SaveDir        : string;
   CurItem        : TAbTarItem;
   AttrEx         : TAbAttrExRec;
 begin
@@ -2145,37 +2164,29 @@
 
         aaAdd, aaFreshen, aaReplace: begin
           try
-            { it's coming from a file }
-            GetDir(0, SaveDir);
-            try {SaveDir}
-              if (BaseDirectory <> '') then
-                ChDir(BaseDirectory);
-              { update metadata }
-              AbFileGetAttrEx(CurItem.DiskFileName, AttrEx);
-              CurItem.ExternalFileAttributes := AttrEx.Mode;
-              CurItem.LastModTimeAsDateTime := AttrEx.Time;
-              { TODO: uid, gid, uname, gname should be added here }
-              { TODO: Add support for different types of files here }
-              if (AttrEx.Mode and AB_FMODE_DIR) <> 0 then begin
-                CurItem.LinkFlag := AB_TAR_LF_DIR;
-                CurItem.UncompressedSize := 0;
+            { update metadata }
+            AbFileGetAttrEx(CurItem.DiskFileName, AttrEx);
+            CurItem.ExternalFileAttributes := AttrEx.Mode;
+            CurItem.LastModTimeAsDateTime := AttrEx.Time;
+            { TODO: uid, gid, uname, gname should be added here }
+            { TODO: Add support for different types of files here }
+            if (AttrEx.Mode and AB_FMODE_DIR) <> 0 then begin
+              CurItem.LinkFlag := AB_TAR_LF_DIR;
+              CurItem.UncompressedSize := 0;
+              CurItem.SaveTarHeaderToStream(NewStream);
+            end
+            else begin
+              TempStream := TFileStreamEx.Create(CurItem.DiskFileName,
+                fmOpenRead or fmShareDenyWrite );
+              try { TempStream }
+                CurItem.UncompressedSize := TempStream.Size;
+                CurItem.StreamPosition := NewStream.Position;{ Reset the Stream Pointer. }
                 CurItem.SaveTarHeaderToStream(NewStream);
-              end
-              else begin
-                TempStream := TFileStream.Create(CurItem.DiskFileName,
-                  fmOpenRead or fmShareDenyWrite );
-                try { TempStream }
-                  CurItem.UncompressedSize := TempStream.Size;
-                  CurItem.StreamPosition := NewStream.Position;{ Reset the Stream Pointer. }
-                  CurItem.SaveTarHeaderToStream(NewStream);
-                  OutTarHelp.WriteArchiveItemSize(TempStream, TempStream.Size);
-                finally { TempStream }
-                  TempStream.Free;
-                end; { TempStream }
-              end;
-            finally {SaveDir}
-              ChDir( SaveDir );
-            end; {SaveDir}
+                OutTarHelp.WriteArchiveItemSize(TempStream, TempStream.Size);
+              finally { TempStream }
+                TempStream.Free;
+              end; { TempStream }
+            end;
           except
             ItemList[i].Action := aaDelete;
             DoProcessItemFailure(ItemList[i], ptAdd, ecFileOpenError, 0);
@@ -2200,7 +2211,7 @@
     else begin
       { need new stream to write }
       FreeAndNil(FStream);
-      FStream := TFileStream.Create(FArchiveName, fmCreate or fmShareDenyWrite);
+      FStream := TFileStreamEx.Create(FArchiveName, fmCreate or fmShareDenyWrite);
       FStream.CopyFrom(NewStream, NewStream.Size);
     end;

Index: AbUnzPrc.pas
===================================================================
--- AbUnzPrc.pas	(revision 512)
+++ AbUnzPrc.pas	(working copy)
@@ -153,7 +153,8 @@
   AbSpanSt,
   AbSWStm,
   AbUnzOutStm,
-  AbUtils;
+  AbUtils,
+  DCClassesUtf8;
 
 { -------------------------------------------------------------------------- }
 procedure AbReverseBits(var W : Word);
@@ -1111,7 +1112,7 @@
   else begin
     InStream := ExtractPrep(ZipArchive, Item);
     try
-      OutStream := TFileStream.Create(UseName, fmCreate or fmShareDenyWrite);
+      OutStream := TFileStreamEx.Create(UseName, fmCreate or fmShareDenyWrite);
       try
         try    {OutStream}
           DoExtract(ZipArchive, Item, InStream, OutStream);
Index: AbVMStrm.pas
===================================================================
--- AbVMStrm.pas	(revision 512)
+++ AbVMStrm.pas	(working copy)
@@ -109,7 +109,8 @@
   {$ENDIF}
   SysUtils,
   AbExcept,
-  AbUtils;
+  AbUtils,
+  DCOSUtils;
 
 const
   LastLRUValue = $7FFFFFFF;
@@ -429,10 +430,10 @@
 begin
   if (vmsSwapHandle = 0) then begin
     vmsSwapFileName := AbCreateTempFile(vmsSwapFileDir);
-    vmsSwapHandle := FileOpen(vmsSwapFileName, fmOpenReadWrite);
+    vmsSwapHandle := mbFileOpen(vmsSwapFileName, fmOpenReadWrite);
     if (vmsSwapHandle <= 0) then begin
       vmsSwapHandle := 0;
-      DeleteFile(vmsSwapFileName);
+      mbDeleteFile(vmsSwapFileName);
       raise EAbVMSErrorOpenSwap.Create( vmsSwapFileName );             
     end;
     vmsSwapFileSize := 0;
@@ -443,7 +444,7 @@
 begin
   if (vmsSwapHandle <> 0) then begin
     FileClose(vmsSwapHandle);
-    DeleteFile(vmsSwapFileName);
+    mbDeleteFile(vmsSwapFileName);
     vmsSwapHandle := 0;
   end;
 end;
Index: AbZBrows.pas
===================================================================
--- AbZBrows.pas	(revision 512)
+++ AbZBrows.pas	(working copy)
@@ -129,7 +129,7 @@
 implementation
 
 uses
-  SysUtils, AbBzip2Typ, AbExcept, AbGzTyp, AbTarTyp, AbUtils;
+  SysUtils, AbBzip2Typ, AbExcept, AbGzTyp, AbTarTyp, AbUtils, DCOSUtils;
 
 { TAbCustomZipBrowser implementation ======================================= }
 
@@ -205,7 +205,7 @@
   FArchive := nil;
 
   if FileName <> '' then begin
-    if FileExists(FileName) then begin { open it }
+    if mbFileExists(FileName) then begin { open it }
       ArcType := ArchiveType;
       if not ForceType then
          ArcType := AbDetermineArcType(FileName, atUnknown);
Index: AbZipper.pas
===================================================================
--- AbZipper.pas	(revision 512)
+++ AbZipper.pas	(working copy)
@@ -173,7 +173,7 @@
 implementation
 
 uses
-  SysUtils, AbUtils, AbTarTyp, AbGzTyp, AbBzip2Typ, AbExcept, AbZipPrc;
+  SysUtils, AbUtils, AbTarTyp, AbGzTyp, AbBzip2Typ, AbExcept, AbZipPrc, DCOSUtils;
 
 { -------------------------------------------------------------------------- }
 constructor TAbCustomZipper.Create( AOwner : TComponent );
@@ -399,7 +399,7 @@
   ArcType := ArchiveType;
 
   if (FileName <> '') then
-    if FileExists(FileName) then begin { open it }
+    if mbFileExists(FileName) then begin { open it }
 
     if not ForceType then
       ArcType := AbDetermineArcType(FileName, atUnknown);
@@ -411,33 +411,33 @@
         end;
 
         atTar : begin
-          FArchive := TAbTarArchive.Create(FileName, fmOpenReadWrite or fmShareDenyNone);
+          FArchive := TAbTarArchive.Create(FileName, fmOpenRead or fmShareDenyNone);
           inherited InitArchive;
         end;
 
         atGZip : begin
-          FArchive := TAbGzipArchive.Create(FileName, fmOpenReadWrite or fmShareDenyNone);
+          FArchive := TAbGzipArchive.Create(FileName, fmOpenRead or fmShareDenyNone);
           TAbGzipArchive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbGzipArchive(FArchive).IsGzippedTar := False;
           inherited InitArchive;
         end;
 
         atGZippedTar : begin
-          FArchive := TAbGzipArchive.Create(FileName, fmOpenReadWrite or fmShareDenyNone);
+          FArchive := TAbGzipArchive.Create(FileName, fmOpenRead or fmShareDenyNone);
           TAbGzipArchive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbGzipArchive(FArchive).IsGzippedTar := True;
           inherited InitArchive;
         end;
 
         atBzip2 : begin
-          FArchive := TAbBzip2Archive.Create(FileName, fmOpenReadWrite or fmShareDenyNone);
+          FArchive := TAbBzip2Archive.Create(FileName, fmOpenRead or fmShareDenyNone);
           TAbBzip2Archive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbBzip2Archive(FArchive).IsBzippedTar := False;
           inherited InitArchive;
         end;
 
         atBzippedTar : begin
-          FArchive := TAbBzip2Archive.Create(FileName, fmOpenReadWrite or fmShareDenyNone);
+          FArchive := TAbBzip2Archive.Create(FileName, fmOpenRead or fmShareDenyNone);
           TAbBzip2Archive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbBzip2Archive(FArchive).IsBzippedTar := True;
           inherited InitArchive;
@@ -455,38 +455,38 @@
 
       case ArcType of
         atZip : begin                                                    
-          FArchive := TAbZipArchive.Create(FileName, fmCreate);
+          FArchive := TAbZipArchive.Create(FileName, fmCreate or fmShareDenyWrite);
           InitArchive;
         end;
 
         atTar : begin
-          FArchive := TAbTarArchive.Create(FileName, fmCreate or fmShareDenyNone);
+          FArchive := TAbTarArchive.Create(FileName, fmCreate or fmShareDenyWrite);
           inherited InitArchive;
         end;
 
         atGZip : begin
-          FArchive := TAbGzipArchive.Create(FileName, fmCreate or fmShareDenyNone);
+          FArchive := TAbGzipArchive.Create(FileName, fmCreate or fmShareDenyWrite);
           TAbGzipArchive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbGzipArchive(FArchive).IsGzippedTar := False;
           inherited InitArchive;
         end;
 
         atGZippedTar : begin
-          FArchive := TAbGzipArchive.Create(FileName, fmCreate or fmShareDenyNone);
+          FArchive := TAbGzipArchive.Create(FileName, fmCreate or fmShareDenyWrite);
           TAbGzipArchive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbGzipArchive(FArchive).IsGzippedTar := True;
           inherited InitArchive;
         end;
 
         atBzip2 : begin
-          FArchive := TAbBzip2Archive.Create(FileName, fmCreate or fmShareDenyNone);
+          FArchive := TAbBzip2Archive.Create(FileName, fmCreate or fmShareDenyWrite);
           TAbBzip2Archive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbBzip2Archive(FArchive).IsBzippedTar := False;
           inherited InitArchive;
         end;
 
         atBzippedTar : begin
-          FArchive := TAbBzip2Archive.Create(FileName, fmCreate or fmShareDenyNone);
+          FArchive := TAbBzip2Archive.Create(FileName, fmCreate or fmShareDenyWrite);
           TAbBzip2Archive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbBzip2Archive(FArchive).IsBzippedTar := True;
           inherited InitArchive;
Index: AbZipPrc.pas
===================================================================
--- AbZipPrc.pas	(revision 512)
+++ AbZipPrc.pas	(working copy)
@@ -67,7 +67,8 @@
   AbVMStrm,
   AbDfBase,
   AbDfEnc,
-  AbSpanSt;
+  AbSpanSt,
+  DCClassesUtf8;
 
 
 { ========================================================================== }
@@ -294,22 +295,13 @@
                  OutStream : TStream );
 var
   UncompressedStream : TStream;
-  SaveDir : string;
   AttrEx : TAbAttrExRec;
 begin
-  GetDir(0, SaveDir);
-  try {SaveDir}
-    if (Sender.BaseDirectory <> '') then
-      ChDir(Sender.BaseDirectory);
-    AbFileGetAttrEx(Item.DiskFileName, AttrEx);
-    if ((AttrEx.Attr and faDirectory) <> 0) then
-      UncompressedStream := TMemoryStream.Create
-    else
-      UncompressedStream :=
-        TFileStream.Create(Item.DiskFileName, fmOpenRead or fmShareDenyWrite);
-  finally {SaveDir}
-    ChDir( SaveDir );
-  end; {SaveDir}
+  AbFileGetAttrEx(Item.DiskFileName, AttrEx);
+  if ((AttrEx.Attr and faDirectory) <> 0) then
+    UncompressedStream := TMemoryStream.Create
+  else
+    UncompressedStream := TFileStreamEx.Create(Item.DiskFileName, fmOpenRead or fmShareDenyWrite);
   try {UncompressedStream}
     {$IFDEF UNIX}
     Item.ExternalFileAttributes := LongWord(AttrEx.Mode) shl 16 + LongWord(AttrEx.Attr);
Index: AbZipTyp.pas
===================================================================
--- AbZipTyp.pas	(revision 512)
+++ AbZipTyp.pas	(working copy)
@@ -407,6 +407,7 @@
     function  GetLastModFileDate : Word; override;
     function  GetLastModFileTime : Word; override;
     function  GetNativeFileAttributes : LongInt; override;
+    function  GetNativeLastModFileTime: Longint; override;
     procedure SetCompressedSize( const Value : Int64 ); override;
     procedure SetCRC32( const Value : Longint ); override;
     procedure SetExternalFileAttributes( Value : LongWord ); override;
@@ -530,8 +531,8 @@
       override;
     destructor Destroy;
       override;
-    function CreateItem(const FileName : string): TAbArchiveItem;
-      override;
+    function CreateItem(const SourceFileName   : string;
+                        const ArchiveDirectory : string): TAbArchiveItem; override;
 
   public {properties}
     property CompressionMethodToUse : TAbZipSupportedMethod
@@ -620,11 +621,13 @@
   {$ENDIF}
   {$ENDIF}
   Math,
-  AbCharset,
   AbResString,
   AbExcept,
   AbVMStrm,
-  SysUtils;
+  SysUtils,
+  DCOSUtils,
+  DCClassesUtf8,
+  DCConvertEncoding;
 
 function VerifyZip(Strm : TStream) : TAbArchiveType;
 { determine if stream appears to be in PkZip format }
@@ -1407,6 +1410,22 @@
   Result := FItemInfo.FileName;
 end;
 { -------------------------------------------------------------------------- }
+function TAbZipItem.GetNativeLastModFileTime: Longint;
+{$IFDEF UNIX}
+var
+  DateTime: TDateTime;
+{$ENDIF}
+begin
+  // Zip stores MS-DOS date/time.
+  LongRec(Result).Hi := LastModFileDate;
+  LongRec(Result).Lo := LastModFileTime;
+
+{$IFDEF UNIX}
+  DateTime := AbDosFileTimeToDateTime(Result);
+  Result   := AbDateTimeToUnixFileTime(DateTime);
+{$ENDIF}
+end;
+{ -------------------------------------------------------------------------- }
 function TAbZipItem.GetShannonFanoTreeCount : Byte;
 begin
   Result := FItemInfo.ShannonFanoTreeCount;
@@ -1428,37 +1447,50 @@
   FieldStream: TStream;
   InfoZipField: PInfoZipUnicodePathRec;
   UnicodeName: UnicodeString;
-  UTF8Name: AnsiString;
+  UTF8Name: UTF8String;
   XceedField: PXceedUnicodePathRec;
+  SystemCode: TAbZipHostOs;
 begin
   FItemInfo.LoadFromStream( Stream );
 
   { decode filename (ANSI/OEM/UTF-8) }
-  if FItemInfo.IsUTF8 or (AbDetectCharSet(FItemInfo.FileName) = csUTF8) then
-    FFileName := UTF8ToString(FItemInfo.FileName)
+  if FItemInfo.IsUTF8 then
+    FFileName := FItemInfo.FileName
   else if FItemInfo.ExtraField.Get(Ab_InfoZipUnicodePathSubfieldID, Pointer(InfoZipField), FieldSize) and
      (FieldSize > SizeOf(TInfoZipUnicodePathRec)) and
      (InfoZipField.Version = 1) and
      (InfoZipField.NameCRC32 = AbCRC32Of(FItemInfo.FileName)) then begin
     SetString(UTF8Name, InfoZipField.UnicodeName,
       FieldSize - SizeOf(TInfoZipUnicodePathRec) + 1);
-    FFileName := UTF8ToString(UTF8Name);
+    FFileName := UTF8Name;
   end
   else if FItemInfo.ExtraField.Get(Ab_XceedUnicodePathSubfieldID, Pointer(XceedField), FieldSize) and
      (FieldSize > SizeOf(TXceedUnicodePathRec)) and
      (XceedField.Signature = Ab_XceedUnicodePathSignature) and
      (XceedField.Length * SizeOf(WideChar) = FieldSize - SizeOf(TXceedUnicodePathRec) + SizeOf(WideChar)) then begin
     SetString(UnicodeName, XceedField.UnicodeName, XceedField.Length);
-    FFileName := string(UnicodeName);
+    FFileName := UTF8Encode(UnicodeName);
   end
-  {$IFDEF MSWINDOWS}
-  else if (GetACP <> GetOEMCP) and ((HostOS = hosDOS) or AbIsOEM(FItemInfo.FileName)) then begin
-    SetLength(FFileName, Length(FItemInfo.FileName));
-    OemToCharBuff(PAnsiChar(FItemInfo.FileName), PChar(FFileName), Length(FFileName));
-  end
-  {$ENDIF}
   else
-    FFileName := string(FItemInfo.FileName);
+  begin
+    SystemCode := HostOS;
+    {$IF DEFINED(MSWINDOWS)}
+    if (GetACP <> GetOEMCP) and (SystemCode = hosDOS) then
+      FFileName := CeOemToUtf8(FItemInfo.FileName)
+    else if (GetACP <> GetOEMCP) and CeTryDecode(FItemInfo.FileName, CP_OEMCP, UnicodeName) then
+      FFileName := UTF8Encode(UnicodeName)
+    else if (SystemCode = hosNTFS) or (SystemCode = hosWinNT) then
+      FFileName := CeAnsiToUtf8(FItemInfo.FileName)
+    else
+    {$ELSEIF DEFINED(LINUX)}
+    if (SystemCode = hosMSDOS) then
+      FFileName := CeOemToUtf8(FItemInfo.FileName)
+    else if (SystemCode = hosNTFS) or (SystemCode = hosWinNT) then
+      FFileName := CeAnsiToUtf8(FItemInfo.FileName)
+    else
+    {$ENDIF}
+      FFileName := FItemInfo.FileName;
+  end;
 
   { read ZIP64 extended header }
   FUncompressedSize := FItemInfo.UncompressedSize;
@@ -1586,7 +1618,7 @@
   {$IFDEF MSWINDOWS}
   AnsiName : AnsiString;
   {$ENDIF}
-  UTF8Name : AnsiString;
+  UTF8Name : UTF8String;
   FieldSize : Word;
   I : Integer;
   InfoZipField : PInfoZipUnicodePathRec;
@@ -1596,24 +1628,20 @@
   {$IFDEF MSWINDOWS}
   FItemInfo.IsUTF8 := False;
   HostOS := hosDOS;
-  if AbTryEncode(Value, CP_OEMCP, False, AnsiName) then
+  if CeTryEncode(UTF8Decode(Value), CP_OEMCP, False, AnsiName) then
     {no-op}
-  else if (GetACP <> GetOEMCP) and AbTryEncode(Value, CP_ACP, False, AnsiName) then
+  else if (GetACP <> GetOEMCP) and CeTryEncode(UTF8Decode(Value), CP_ACP, False, AnsiName) then
     HostOS := hosWinNT
-  else if AbTryEncode(Value, CP_OEMCP, True, AnsiName) then
-    {no-op}
-  else if (GetACP <> GetOEMCP) and AbTryEncode(Value, CP_ACP, True, AnsiName) then
-    HostOS := hosWinNT
   else
     FItemInfo.IsUTF8 := True;
   if FItemInfo.IsUTF8 then
-    FItemInfo.FileName := Utf8Encode(Value)
+    FItemInfo.FileName := Value
   else
     FItemInfo.FileName := AnsiName;
   {$ENDIF}
   {$IFDEF UNIX}
-  FItemInfo.FileName := AnsiString(Value);
-  FItemInfo.IsUTF8 := AbSysCharSetIsUTF8;
+  FItemInfo.FileName := Value;
+  FItemInfo.IsUTF8 := SystemEncodingUtf8;
   {$ENDIF}
 
   UseExtraField := False;
@@ -1626,7 +1654,7 @@
     end;
 
   if UseExtraField then begin
-    UTF8Name := AnsiToUTF8(Value);
+    UTF8Name := Value;
     FieldSize := SizeOf(TInfoZipUnicodePathRec) + Length(UTF8Name) - 1;
     GetMem(InfoZipField, FieldSize);
     try
@@ -1762,20 +1790,28 @@
   inherited Destroy;
 end;
 { -------------------------------------------------------------------------- }
-function TAbZipArchive.CreateItem( const FileName : string ): TAbArchiveItem;
+function TAbZipArchive.CreateItem(const SourceFileName   : string;
+                                  const ArchiveDirectory : string): TAbArchiveItem;
 var
-  FileSpec : string;
+  FullSourceFileName, FullArchiveFileName: string;
 begin
-  FileSpec := FileName;
   Result := TAbZipItem.Create;
   with TAbZipItem( Result ) do begin
     CompressionMethod := cmDeflated;
     GeneralPurposeBitFlag := 0;
     CompressedSize := 0;
     CRC32 := 0;
-    DiskFileName := ExpandFileName(FileSpec);
-    FileName := FixName(FileSpec);
     RelativeOffset := 0;
+
+    MakeFullNames(SourceFileName, ArchiveDirectory,
+                  FullSourceFileName, FullArchiveFileName);
+
+    if mbDirectoryExists(FullSourceFileName) then begin
+      FullSourceFileName := IncludeTrailingPathDelimiter(FullSourceFileName);
+    end;
+
+    Result.FileName     := FullArchiveFileName;
+    Result.DiskFileName := FullSourceFileName;
   end;
 end;
 { -------------------------------------------------------------------------- }
@@ -1930,8 +1966,8 @@
     AbStripDots( lValue );
 
   for i := 1 to Length( lValue ) do
-    if lValue[i] = '\' then
-      lValue[i] := '/';
+    if lValue[i] = AbDosPathDelim then
+      lValue[i] := AbUnixPathDelim;
   Result := lValue;
 end;
 { -------------------------------------------------------------------------- }
@@ -1983,7 +2019,7 @@
         FStatus := asInvalid; //TODO: Status updates are extremely inconsistent
         raise EAbUserAbort.Create;
       end;
-      FStream := TFileStream.Create( ArchiveName, Mode );
+      FStream := TFileStreamEx.Create( ArchiveName, Mode );
       TailPosition := FindCentralDirectoryTail( FStream );
     end;
   end;
@@ -2302,7 +2338,7 @@
         if FOwnsStream then begin
           {need new stream to write}
           FreeAndNil(FStream);
-          FStream := TFileStream.Create(FArchiveName,
+          FStream := TFileStreamEx.Create(FArchiveName,
             fmOpenReadWrite or fmShareDenyWrite);
         end;
         FStream.Size := 0;
