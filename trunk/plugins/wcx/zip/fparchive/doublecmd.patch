Index: AbArcTyp.pas
===================================================================
--- AbArcTyp.pas	(revision 512)
+++ AbArcTyp.pas	(working copy)
@@ -316,6 +316,10 @@
     procedure GetFreshenTarget(Item : TAbArchiveItem);
     function  GetItemCount : Integer;
     procedure MakeLogEntry(const FN: string; LT : TAbLogType);
+    procedure MakeFullNames(const SourceFileName: String;
+                            const ArchiveDirectory: String;
+                            out   FullSourceFileName: String;
+                            out   FullArchiveFileName: String);
     procedure ReplaceAt(Index : Integer);
     procedure SaveIfNeeded(aItem : TAbArchiveItem);
     procedure SetBaseDirectory(Value : string);
@@ -323,7 +327,16 @@
     procedure SetLogging(Value : Boolean);
 
   protected {abstract methods}
-    function CreateItem(const FileSpec : string): TAbArchiveItem;
+    function CreateItem(const SourceFileName : string;
+                        const ArchiveDirectory : string): TAbArchiveItem;
+    {SourceFileName   - full or relative path to a file/dir on some file system
+                        If full path, BaseDirectory is used to determine relative path}
+    {ArchiveDirectory - path to a directory in the archive the file/dir will be in}
+    {Example:
+      FBaseDirectory      = /dir
+      SourceFileName      = /dir/subdir/file
+      ArchiveDirectory    = files/storage  (or files/storage/)
+      -> name in archive  = files/storage/subdir/file}
       virtual; abstract;
     procedure ExtractItemAt(Index : Integer; const UseName : string);
       virtual; abstract;
@@ -384,6 +397,7 @@
       override;
     procedure Add(aItem : TAbArchiveItem);
       virtual;
+    procedure AddEntry(const Path : String; const ArchiveDirectory : String);
     procedure AddFiles(const FileMask : string; SearchAttr : Integer);
     procedure AddFilesEx(const FileMask, ExclusionMask : string;
       SearchAttr : Integer);
@@ -565,7 +579,9 @@
   AbExcept,
   AbDfBase,
   AbConst,
-  AbResString;
+  AbResString,
+  DCOSUtils,
+  DCClassesUtf8;
 
 
 { TAbArchiveItem implementation ============================================ }
@@ -980,7 +996,7 @@
   {create an archive by opening a filestream on filename with the given mode}
 begin
   FOwnsStream := True;
-  CreateFromStream(TFileStream.Create(FileName, Mode), FileName);
+  CreateFromStream(TFileStreamEx.Create(FileName, Mode), FileName);
   FMode := Mode;
 end;
 { -------------------------------------------------------------------------- }
@@ -1032,6 +1048,19 @@
   end;
 end;
 { -------------------------------------------------------------------------- }
+procedure TAbArchive.AddEntry(const Path : String; const ArchiveDirectory : String);
+var
+  Item : TAbArchiveItem;
+  FullSourceFileName, FullArchiveFileName : String;
+begin
+  MakeFullNames(Path, ArchiveDirectory, FullSourceFileName, FullArchiveFileName);
+
+  if (FullSourceFileName <> FArchiveName) then begin
+    Item := CreateItem(Path, ArchiveDirectory);
+    Add(Item);
+  end;
+end;
+{ -------------------------------------------------------------------------- }
 procedure TAbArchive.AddFiles(const FileMask : string; SearchAttr : Integer);
   {Add files to the archive where the disk filespec matches}
 begin
@@ -1043,17 +1072,15 @@
   {Add files matching Filemask except those matching ExclusionMask}
 var
   PathType : TAbPathType;
-  IsWild : Boolean;
   SaveDir : string;
   Mask : string;
   MaskF : string;
 
-  procedure CreateItems(Wild, Recursing : Boolean);
+  procedure CreateItems(Recursing : Boolean);
   var
     i : Integer;
     Files : TStrings;
     FilterList : TStringList;
-    Item : TAbArchiveItem;
   begin
     FilterList := TStringList.Create;
     try
@@ -1064,21 +1091,12 @@
         try
 
           AbFindFilesEx(Mask, SearchAttr, Files, Recursing);
-          if (Files.Count > 0) then
+          if (Files.Count > 0) then begin
             for i := 0 to pred(Files.Count) do
               if FilterList.IndexOf(Files[i]) < 0 then
-                if not Wild then begin
-                  if (Files[i] <> FArchiveName) then begin
-                    Item := CreateItem(Files[i]);
-                    Add(Item);
-                  end;
-                end else begin
-                  if (AbAddBackSlash(FBaseDirectory) + Files[i]) <> FArchiveName
-                    then begin
-                      Item := CreateItem(Files[i]);
-                      Add(Item);
-                    end;
-                end;
+                AddEntry(Files[i], Files[i]);
+            FIsDirty := true;
+          end;
         finally
           Files.Free;
         end;
@@ -1093,7 +1111,6 @@
     SearchAttr := SearchAttr and not faDirectory;
 
   CheckValid;
-  IsWild := (Pos('*', FileMask) > 0) or (Pos('?', FileMask) > 0);
   PathType := AbGetPathType(FileMask);
 
   Mask := FileMask;
@@ -1108,7 +1125,7 @@
         if BaseDirectory <> '' then
           ChDir(BaseDirectory);
         try
-          CreateItems(IsWild, soRecurse in StoreOptions);
+          CreateItems(soRecurse in StoreOptions);
         finally
           if BaseDirectory <> '' then
             ChDir(SaveDir);
@@ -1116,7 +1133,7 @@
       end;
     ptAbsolute :
       begin
-        CreateItems(IsWild, soRecurse in StoreOptions);
+        CreateItems(soRecurse in StoreOptions);
       end;
   end;
 end;
@@ -1128,7 +1145,7 @@
   Item : TAbArchiveItem;
   PT : TAbProcessType;                                               
 begin
-  Item := CreateItem(NewName);
+  Item := CreateItem('', NewName);
   CheckValid;
 
   PT := ptAdd;
@@ -1196,14 +1213,14 @@
     UseName := AbAddBackSlash(BaseDirectory) + UseName;
 
   Path := ExtractFileDir(UseName);
-  if (Path <> '') and not DirectoryExists(Path) then
+  if (Path <> '') and not mbDirectoryExists(Path) then
     if (eoCreateDirs in ExtractOptions) then
       AbCreateDirectory(Path)
     else
       raise EAbNoSuchDirectory.Create;
 
   Result := True;
-  if not Item.IsDirectory and FileExists(UseName) then
+  if not Item.IsDirectory and mbFileExists(UseName) then
     DoConfirmOverwrite(UseName, Result);
 end;
 { -------------------------------------------------------------------------- }
@@ -1560,11 +1577,12 @@
 begin
   CheckValid;
   Index := FindItem(aItem);
-  if Index <> -1 then begin
+  if Index <> -1 then
+  begin
+    FreshenAt(Index);
     {point existing item at the new file}
     if AbGetPathType(aItem.DiskFileName) = ptAbsolute then
       FItemList[Index].DiskFileName := aItem.DiskFileName;
-    FreshenAt(Index);
   end;
 end;
 { -------------------------------------------------------------------------- }
@@ -1625,7 +1643,7 @@
 { -------------------------------------------------------------------------- }
 function TAbArchive.FreshenRequired(Item : TAbArchiveItem) : Boolean;
 var
-  FS : TFileStream;
+  FS : TFileStreamEx;
   DateTime : LongInt;
   FileTime : Word;
   FileDate : Word;
@@ -1636,8 +1654,8 @@
   if BaseDirectory <> '' then
     ChDir(BaseDirectory);
   try
-    FS := TFileStream.Create(Item.DiskFileName,
-                              fmOpenRead or fmShareDenyWrite);
+    FS := TFileStreamEx.Create(Item.DiskFileName,
+                               fmOpenRead or fmShareDenyWrite);
     try
       DateTime := FileGetDate(FS.Handle);
       FileTime := LongRec(DateTime).Lo;
@@ -1761,6 +1779,45 @@
   end;
 end;
 { -------------------------------------------------------------------------- }
+procedure TAbArchive.MakeFullNames(const SourceFileName: String;
+                                   const ArchiveDirectory: String;
+                                   out   FullSourceFileName: String;
+                                   out   FullArchiveFileName: String);
+var
+  PathType : TAbPathType;
+  RelativeSourceFileName: String;
+begin
+  PathType := AbGetPathType(SourceFileName);
+  case PathType of
+    ptNone, ptRelative :
+      begin
+        if FBaseDirectory <> '' then
+          FullSourceFileName := AbAddBackSlash(FBaseDirectory) + SourceFileName
+        else
+          FullSourceFileName := SourceFileName;
+
+        RelativeSourceFileName := SourceFileName;
+      end;
+    ptAbsolute :
+      begin
+        FullSourceFileName := SourceFileName;
+
+        if FBaseDirectory <> '' then
+          RelativeSourceFileName := ExtractRelativepath(AbAddBackSlash(FBaseDirectory),
+                                                        SourceFileName)
+        else
+          RelativeSourceFileName := ExtractFileName(SourceFileName);
+      end;
+  end;
+
+  if ArchiveDirectory <> '' then
+    FullArchiveFileName := AbAddBackSlash(ArchiveDirectory) + RelativeSourceFileName
+  else
+    FullArchiveFileName := RelativeSourceFileName;
+
+  FullArchiveFileName := FixName(FullArchiveFileName);
+end;
+{ -------------------------------------------------------------------------- }
 procedure TAbArchive.Move(aItem : TAbArchiveItem; const NewStoredPath : string);
 var
   Confirm : Boolean;
@@ -1807,11 +1864,12 @@
 begin
   CheckValid;
   Index := FindItem(aItem);
-  if Index <> -1 then begin
+  if Index <> -1 then
+  begin
+    ReplaceAt(Index);
     {point existing item at the new file}
     if AbGetPathType(aItem.DiskFileName) = ptAbsolute then
       FItemList[Index].DiskFileName := aItem.DiskFileName;
-    ReplaceAt(Index);
   end;
 end;
 { -------------------------------------------------------------------------- }
@@ -1865,7 +1923,7 @@
     if Value[Length(Value)] = AbPathDelim then
       if (Length(Value) > 1) and (Value[Length(Value) - 1] <> ':') then
         System.Delete(Value, Length(Value), 1);
-  if (Length(Value) = 0) or DirectoryExists(Value) then
+  if (Length(Value) = 0) or mbDirectoryExists(Value) then
     FBaseDirectory := Value
   else
     raise EAbNoSuchDirectory.Create;
@@ -1973,7 +2031,7 @@
   Len, Offset : Integer;
 begin
   Len := SizeOf(TAbExtraSubField) + aSubField.Len;
-  Offset := PtrInt(aSubField) - PtrInt(Pointer(FBuffer));
+  Offset := Pointer(aSubField) - Pointer(FBuffer);
   if Offset + Len < Length(FBuffer) then
     Move(FBuffer[Offset + Len], aSubField^, Length(FBuffer) - Offset - Len);
   SetLength(FBuffer, Length(FBuffer) - Len);
@@ -2001,9 +2059,9 @@
   end
   else begin
     BytesLeft := Length(FBuffer) -
-      Integer(PtrInt(aCurField) - PtrInt(Pointer(FBuffer))) -
+      (Pointer(aCurField) - Pointer(FBuffer)) -
       SizeOf(TAbExtraSubField) - aCurField.Len;
-    aCurField := Pointer(PtrInt(aCurField) + aCurField.Len + SizeOf(TAbExtraSubField));
+    Inc(Pointer(aCurField), aCurField.Len + SizeOf(TAbExtraSubField));
   end;
   Result := (BytesLeft >= SizeOf(TAbExtraSubField));
   if Result and (BytesLeft < SizeOf(TAbExtraSubField) + aCurField.Len) then
Index: AbBitBkt.pas
===================================================================
--- AbBitBkt.pas	(revision 512)
+++ AbBitBkt.pas	(working copy)
@@ -47,7 +47,7 @@
       FBufPosn : longint;
       FPosn    : Int64;
       FSize    : Int64;
-      FTail    : longint;
+      FTail    : Int64;
     protected
     public
       constructor Create(aBufSize : cardinal);
@@ -108,8 +108,8 @@
 {--------}
 function TAbBitBucketStream.Read(var Buffer; Count : Longint) : Longint;
 var
-  Chunk2Size : longint;
-  Chunk1Size : longint;
+  Chunk2Size : Int64;
+  Chunk1Size : Int64;
   OutBuffer  : PByte;
 begin
   OutBuffer := @Buffer;
@@ -146,7 +146,7 @@
   end;
   if (Chunk2Size > 0) then begin
     {we've wrapped}
-    Move(FBuffer[0], PByte(PtrInt(OutBuffer) + PtrInt(Chunk1Size))^, Chunk2Size);
+    Move(FBuffer[0], (OutBuffer + Chunk1Size)^, Chunk2Size);
     FBufPosn := Chunk2Size;
     inc(FPosn, Chunk2Size);
   end;
@@ -155,8 +155,8 @@
 {--------}
 function TAbBitBucketStream.Write(const Buffer; Count : Longint) : Longint;
 var
-  Chunk2Size : longint;
-  Chunk1Size : longint;
+  Chunk2Size : Int64;
+  Chunk1Size : Int64;
   InBuffer   : PByte;
   Overage    : longint;
 begin
@@ -186,7 +186,7 @@
   {if the second chunk size is not zero, write the second chunk; note
    that we have wrapped}
   if (Chunk2Size > 0) then begin
-    Move(PByte(PtrInt(InBuffer) + PtrInt(Chunk1Size))^, FBuffer[0], Chunk2Size);
+    Move((InBuffer + Chunk1Size)^, FBuffer[0], Chunk2Size);
     FTail := Chunk2Size;
   end;
   {the stream size and position have changed}
Index: AbBrowse.pas
===================================================================
--- AbBrowse.pas	(revision 512)
+++ AbBrowse.pas	(working copy)
@@ -220,13 +220,15 @@
 uses
   SysUtils,
   AbExcept,
-{$IFDEF MSWINDOWS}
+{$IF DEFINED(ExtractCabSupport)}
   AbCabTyp,
 {$ENDIF}
   AbZipTyp,
   AbTarTyp,
   AbGzTyp,
-  AbBzip2Typ;
+  AbBzip2Typ,
+  DCOSUtils,
+  DCClassesUtf8;
 
 { TAbBaseBrowser implementation ======================================= }
 
@@ -515,68 +517,52 @@
 function AbDetermineArcType(const FN : string; AssertType : TAbArchiveType) : TAbArchiveType;
 var
   Ext : string;
-  FS : TFileStream;
+  FS : TStream = nil;
 begin
   Result := AssertType;
-  if Result = atUnknown then begin
+  { Guess archive type based on it's content }
+  if (Result = atUnknown) and mbFileExists(FN) and (AbFileGetSize(FN) > 0) then
+    try
+      FS := TFileStreamEx.Create(FN, fmOpenRead or fmShareDenyNone);
+      Result := VerifyZip(FS);
+      if Result = atUnknown then
+        Result := VerifySelfExtracting(FS);
+      if Result = atUnknown then
+        Result := VerifyTar(FS);
+      if Result = atUnknown then
+        Result := VerifyGzip(FS);
+      {$IF DEFINED(ExtractCabSupport)}
+      if Result = atUnknown then
+        Result := VerifyCab(FS);
+      {$ENDIF}
+      if Result = atUnknown then
+        Result := VerifyBzip2(FS);
+    finally
+      if Assigned(FS) then
+        FreeAndNil(FS);
+    end
+  else if Result = atUnknown then begin
     { Guess archive type based on it's extension }
     Ext := UpperCase(ExtractFileExt(FN));
     if (Ext = '.ZIP') or (Ext = '.JAR') then
-      Result := atZip;
-    if (Ext = '.EXE') then
-      Result := atSelfExtZip;
-    if (Ext = '.TAR') then
-      Result := atTar;
-    if (Ext = '.GZ') then
-      Result := atGzip;
-    if (Ext = '.TGZ') then
-      Result := atGzippedTar;
-    if (Ext = '.CAB') then
-      Result := atCab;
-    if (Ext = '.BZ2') then
-      Result := atBzip2;
-    if (Ext = '.TBZ') then
+      Result := atZip
+    else if (Ext = '.TAR') then
+      Result := atTar
+    else if (Ext = '.GZ') then
+      Result := atGzip
+    else if (Ext = '.TGZ') then
+      Result := atGzippedTar
+    else if (Ext = '.CAB') then
+      Result := atCab
+    else if (Ext = '.BZ2') then
+      Result := atBzip2
+    else if (Ext = '.TBZ') then
       Result := atBzippedTar;
   end;
-  {$IFNDEF MSWINDOWS}
+  {$IF NOT DEFINED(ExtractCabSupport)}
   if Result = atCab then
     Result := atUnknown;
   {$ENDIF}
-  if FileExists(FN) and (AbFileGetSize(FN) > 0) then begin
-    { If the file doesn't exist (or is empty) presume to make one, otherwise
-      guess or verify the contents }
-    FS := TFileStream.Create(FN, fmOpenRead or fmShareDenyNone);
-    try
-      if Result = atUnknown then
-        Result := AbDetermineArcType(FS)
-      else begin
-        case Result of
-          atZip : begin
-            Result := VerifyZip(FS);
-          end;
-          atSelfExtZip : begin
-            Result := VerifySelfExtracting(FS);
-          end;
-          atTar : begin
-            Result := VerifyTar(FS);
-          end;
-          atGzip, atGzippedTar: begin
-            Result := VerifyGzip(FS);
-          end;
-          {$IFDEF MSWINDOWS}
-          atCab : begin
-            Result := VerifyCab(FS);
-          end;
-          {$ENDIF}
-          atBzip2, atBzippedTar: begin
-            Result := VerifyBzip2(FS);
-          end;
-        end;
-      end;
-    finally
-      FS.Free;
-    end;
-  end;
 end;
 { -------------------------------------------------------------------------- }
 function AbDetermineArcType(aStream: TStream): TAbArchiveType;
@@ -591,7 +577,7 @@
     Result := VerifyGzip(aStream);
   if Result = atUnknown then
     Result := VerifyBzip2(aStream);
-  {$IFDEF MSWINDOWS}
+  {$IF DEFINED(ExtractCabSupport)}
   if Result = atUnknown then
     Result := VerifyCab(aStream);
   {$ENDIF}
Index: AbBzip2Typ.pas
===================================================================
--- AbBzip2Typ.pas	(revision 512)
+++ AbBzip2Typ.pas	(working copy)
@@ -86,7 +86,8 @@
 
   protected
     { Inherited Abstract functions }
-    function CreateItem(const FileSpec : string): TAbArchiveItem; override;
+    function CreateItem(const SourceFileName   : string;
+                        const ArchiveDirectory : string): TAbArchiveItem; override;
     procedure ExtractItemAt(Index : Integer; const NewName : string); override;
     procedure ExtractItemToStreamAt(Index : Integer; aStream : TStream); override;
     procedure LoadArchive; override;
@@ -118,7 +119,7 @@
   Windows, // Fix inline warnings
 {$ENDIF}
   StrUtils, SysUtils,
-  AbBzip2, AbExcept, AbVMStrm, AbBitBkt;
+  AbBzip2, AbExcept, AbVMStrm, AbBitBkt, DCOSUtils, DCClassesUtf8;
 
 { ****************** Helper functions Not from Classes Above ***************** }
 function VerifyHeader(const Header : TAbBzip2Header) : Boolean;
@@ -193,20 +194,29 @@
   FState    := gsBzip2;
 end;
 { -------------------------------------------------------------------------- }
-function TAbBzip2Archive.CreateItem(const FileSpec: string): TAbArchiveItem;
+function TAbBzip2Archive.CreateItem(const SourceFileName   : string;
+                                    const ArchiveDirectory : string): TAbArchiveItem;
+var
+  Bz2Item : TAbBzip2Item;
+  FullSourceFileName, FullArchiveFileName: String;
 begin
   if IsBzippedTar and TarAutoHandle then begin
     SwapToTar;
-    Result := inherited CreateItem(FileSpec);
+    Result := inherited CreateItem(SourceFileName, ArchiveDirectory);
   end
   else begin
     SwapToBzip2;
-    Result := TAbBzip2Item.Create;
+    Bz2Item := TAbBzip2Item.Create;
     try
-      Result.DiskFileName := ExpandFileName(FileSpec);
-      Result.FileName := FixName(FileSpec);
+      MakeFullNames(SourceFileName, ArchiveDirectory,
+                    FullSourceFileName, FullArchiveFileName);
+
+      Bz2Item.FileName := FullArchiveFileName;
+      Bz2Item.DiskFileName := FullSourceFileName;
+
+      Result := Bz2Item;
     except
-      Result.Free;
+      Result := nil;
       raise;
     end;
   end;
@@ -223,7 +233,7 @@
 procedure TAbBzip2Archive.ExtractItemAt(Index: Integer;
   const NewName: string);
 var
-  OutStream : TFileStream;
+  OutStream : TStream;
 begin
   if IsBzippedTar and TarAutoHandle then begin
     SwapToTar;
@@ -231,7 +241,7 @@
   end
   else begin
     SwapToBzip2;
-    OutStream := TFileStream.Create(NewName, fmCreate or fmShareDenyNone);
+    OutStream := TFileStreamEx.Create(NewName, fmCreate or fmShareDenyNone);
     try
       try
         ExtractItemToStreamAt(Index, OutStream);
@@ -242,12 +252,12 @@
     except
       on E : EAbUserAbort do begin
         FStatus := asInvalid;
-        if FileExists(NewName) then
-          DeleteFile(NewName);
+        if mbFileExists(NewName) then
+          mbDeleteFile(NewName);
         raise;
       end else begin
-        if FileExists(NewName) then
-          DeleteFile(NewName);
+        if mbFileExists(NewName) then
+          mbDeleteFile(NewName);
         raise;
       end;
     end;
@@ -347,7 +357,7 @@
             if CurItem.Action = aaStreamAdd then
               CompStream.CopyFrom(InStream, 0){ Copy/compress entire Instream to FBzip2Stream }
             else begin
-              InputFileStream := TFileStream.Create(CurItem.DiskFileName, fmOpenRead or fmShareDenyWrite );
+              InputFileStream := TFileStreamEx.Create(CurItem.DiskFileName, fmOpenRead or fmShareDenyWrite );
               try
                 CompStream.CopyFrom(InputFileStream, 0);{ Copy/compress entire Instream to FBzip2Stream }
               finally
Index: AbDfInW.pas
===================================================================
--- AbDfInW.pas	(revision 512)
+++ AbDfInW.pas	(working copy)
@@ -261,8 +261,7 @@
     HashInx :=
        ((HashInx shl c_HashShift) xor longint(CurPos[2])) and
        c_HashMask;
-    HashChains^[longint(CurPos) and FWinMask] :=
-       HashHeads^[HashInx];
+    HashChains^[PtrUInt(CurPos) and FWinMask] := HashHeads^[HashInx];
     HashHeads^[HashInx] := CurPos;
     inc(CurPos);
   end;
@@ -367,7 +366,6 @@
   {$ENDIF}
 {$ENDIF}
 type
-  PLongint = ^longint;
   PWord    = ^word;
 var
   MaxLen     : longint;
@@ -406,7 +404,7 @@
 
   {update the chain itself: set the entry for this position equal to
    the previous string position}
-  FHashChains^[longint(CurPos) and FWinMask] := PrevStrPos;
+  FHashChains^[PtrUInt(CurPos) and FWinMask] := PrevStrPos;
 
   {calculate the maximum match we could do at this position}
   MaxMatch := (FLookAheadEnd - CurPos);
@@ -602,7 +600,7 @@
       Break;
 
     {otherwise move onto the next position}
-    PrevStrPos := FHashChains^[longint(PrevStrPos) and FWinMask];
+    PrevStrPos := FHashChains^[PtrUInt(PrevStrPos) and FWinMask];
   end;
   {$ENDIF}
 
@@ -700,13 +698,11 @@
 end;
 {--------}
 procedure TAbDfInputWindow.iwSlide;
-type
-  PLongint = ^longint;
 var
   i : integer;
-  ByteCount : integer;
-  Buffer    : longint;
-  ListItem  : PLongint;
+  ByteCount : PtrInt;
+  Buffer    : PAnsiChar;
+  ListItem  : PPointer;
 begin
   {move current valid data back to the start of the buffer}
   ByteCount := FLookAheadEnd - FStart;
@@ -719,22 +715,22 @@
   dec(FLookAheadEnd, ByteCount);
 
   {patch up the hash table: the head pointers}
-  Buffer := longint(FBuffer);
-  ListItem := PLongint(@FHashHeads^[0]);
+  Buffer := FBuffer;
+  ListItem := @FHashHeads^[0];
   for i := 0 to pred(c_HashCount) do begin
     dec(ListItem^, ByteCount);
     if (ListItem^ < Buffer) then
-      ListItem^ := 0;
-    inc(PAnsiChar(ListItem), sizeof(pointer));
+      ListItem^ := nil;
+    inc(ListItem);
   end;
 
   {..the chain pointers}
-  ListItem  := PLongint(@FHashChains^[0]);
+  ListItem  := @FHashChains^[0];
   for i := 0 to pred(FWinSize) do begin
     dec(ListItem^, ByteCount);
     if (ListItem^ < Buffer) then
-      ListItem^ := 0;
-    inc(PAnsiChar(ListItem), sizeof(pointer));
+      ListItem^ := nil;
+    inc(ListItem);
   end;
 
   {now read some more data from the stream}
Index: AbDfStrm.pas
===================================================================
--- AbDfStrm.pas	(revision 512)
+++ AbDfStrm.pas	(working copy)
@@ -230,7 +230,8 @@
   {save the on progress handler}
   if Assigned(aOnProgress) and (aStreamSize > 0) then begin
     FOnProgress := aOnProgress;
-    FStreamSize := aStreamSize;
+    //FStreamSize := aStreamSize;
+    FStreamSize := aStream.Size - aStream.Position;
   end;
 end;
 {--------}
Index: AbSelfEx.pas
===================================================================
--- AbSelfEx.pas	(revision 512)
+++ AbSelfEx.pas	(working copy)
@@ -49,9 +49,9 @@
     FStubExe      : string;
     FZipFile      : string;
     FSelfExe      : string;
-    FStubStream   : TFileStream;
-    FZipStream    : TFileStream;
-    FSelfStream    : TFileStream;
+    FStubStream   : TStream;
+    FZipStream    : TStream;
+    FSelfStream    : TStream;
     FOnGetStubExe : TAbGetFileEvent;
     FOnGetZipFile : TAbGetFileEvent;
 
@@ -88,7 +88,7 @@
 {$IFDEF LibcAPI}
   Libc,
 {$ENDIF}
-  AbExcept, AbZipTyp;
+  AbExcept, AbZipTyp, DCOSUtils, DCClassesUtf8;
 
 { -------------------------------------------------------------------------- }
 function TAbMakeSelfExe.Execute : Boolean;
@@ -100,20 +100,20 @@
     DoGetStubExe(Abort);
   if Abort then
     raise EAbUserAbort.Create;
-  if not FileExists(FStubExe) then
+  if not mbFileExists(FStubExe) then
     raise EAbFileNotFound.Create;
   if (FZipFile = '') then
     DoGetZipFile(Abort);
   if Abort then
     raise EAbUserAbort.Create;
-  if not FileExists(FZipFile) then
+  if not mbFileExists(FZipFile) then
     raise EAbFileNotFound.Create;
 
-  FStubStream := TFileStream.Create(FStubExe, fmOpenRead or fmShareDenyWrite);
-  FZipStream := TFileStream.Create(FZipFile, fmOpenRead or fmShareDenyWrite);
+  FStubStream := TFileStreamEx.Create(FStubExe, fmOpenRead or fmShareDenyWrite);
+  FZipStream := TFileStreamEx.Create(FZipFile, fmOpenRead or fmShareDenyWrite);
   if (FSelfExe = '') then
     FSelfExe := ChangeFileExt(FZipFile, '.exe');
-  FSelfStream := TFileStream.Create(FSelfExe, fmCreate or fmShareExclusive);
+  FSelfStream := TFileStreamEx.Create(FSelfExe, fmCreate or fmShareExclusive);
   try
     MakeSelfExtracting(FStubStream, FZipStream, FSelfStream);
     Result := True;
Index: AbSpanSt.pas
===================================================================
--- AbSpanSt.pas	(revision 512)
+++ AbSpanSt.pas	(working copy)
@@ -142,7 +142,7 @@
 {$IFDEF MSWINDOWS}
   Windows,
 {$ENDIF}
-  Math, RTLConsts, SysUtils, AbUtils, AbExcept;
+  Math, RTLConsts, SysUtils, AbUtils, AbExcept, DCOSUtils, DCClassesUtf8;
 
 
 {============================================================================}
@@ -181,7 +181,7 @@
 begin
   inherited Create(ArchiveName);
   FCurrentImage := CurrentImage;
-  FIsSplit := FileExists(GetImageName(1)) or not AbDriveIsRemovable(ArchiveName);
+  FIsSplit := mbFileExists(GetImageName(1)) or not AbDriveIsRemovable(ArchiveName);
   FLastImage := CurrentImage;
   FStream := Stream;
 end;
@@ -218,7 +218,7 @@
   end
   else
     raise EAbUserAbort.Create;
-  FStream := TFileStream.Create(ImageName, fmOpenRead or fmShareDenyWrite);
+  FStream := TFileStreamEx.Create(ImageName, fmOpenRead or fmShareDenyWrite);
 end;
 {------------------------------------------------------------------------------}
 function TAbSpanReadStream.Read(var Buffer; Count: Longint): Longint;
@@ -273,7 +273,7 @@
 procedure TAbSpanReadStream.SetOnRequestImage(Value: TAbRequestImageEvent);
 begin
   FOnRequestImage := Value;
-  FIsSplit := FileExists(GetImageName(1)) or not AbDriveIsRemovable(FArchiveName);
+  FIsSplit := mbFileExists(GetImageName(1)) or not AbDriveIsRemovable(FArchiveName);
 end;
 
 {============================================================================}
@@ -302,7 +302,7 @@
   FreeAndNil(FStream);
   Inc(FCurrentImage);
   if FThreshold > 0 then
-    RenameFile(FArchiveName, GetImageName(FCurrentImage))
+    mbRenameFile(FArchiveName, GetImageName(FCurrentImage))
   else begin
     if Assigned(FOnRequestBlankDisk) then begin
       Abort := False;
@@ -316,7 +316,7 @@
       raise EAbUserAbort.Create;
     AbSetSpanVolumeLabel(AbDrive(FArchiveName), FCurrentImage);
   end;
-  FStream := TFileStream.Create(FArchiveName, fmCreate or fmShareDenyWrite);
+  FStream := TFileStreamEx.Create(FArchiveName, fmCreate or fmShareDenyWrite);
   FImageSize := 0;
 end;
 {------------------------------------------------------------------------------}
Index: AbUnzPrc.pas
===================================================================
--- AbUnzPrc.pas	(revision 512)
+++ AbUnzPrc.pas	(working copy)
@@ -153,7 +153,8 @@
   AbSpanSt,
   AbSWStm,
   AbUnzOutStm,
-  AbUtils;
+  AbUtils,
+  DCClassesUtf8;
 
 { -------------------------------------------------------------------------- }
 procedure AbReverseBits(var W : Word);
@@ -1111,7 +1112,7 @@
   else begin
     InStream := ExtractPrep(ZipArchive, Item);
     try
-      OutStream := TFileStream.Create(UseName, fmCreate or fmShareDenyWrite);
+      OutStream := TFileStreamEx.Create(UseName, fmCreate or fmShareDenyWrite);
       try
         try    {OutStream}
           DoExtract(ZipArchive, Item, InStream, OutStream);
Index: AbVMStrm.pas
===================================================================
--- AbVMStrm.pas	(revision 512)
+++ AbVMStrm.pas	(working copy)
@@ -109,7 +109,8 @@
   {$ENDIF}
   SysUtils,
   AbExcept,
-  AbUtils;
+  AbUtils,
+  DCOSUtils;
 
 const
   LastLRUValue = $7FFFFFFF;
@@ -429,10 +430,10 @@
 begin
   if (vmsSwapHandle = 0) then begin
     vmsSwapFileName := AbCreateTempFile(vmsSwapFileDir);
-    vmsSwapHandle := FileOpen(vmsSwapFileName, fmOpenReadWrite);
+    vmsSwapHandle := mbFileOpen(vmsSwapFileName, fmOpenReadWrite);
     if (vmsSwapHandle <= 0) then begin
       vmsSwapHandle := 0;
-      DeleteFile(vmsSwapFileName);
+      mbDeleteFile(vmsSwapFileName);
       raise EAbVMSErrorOpenSwap.Create( vmsSwapFileName );             
     end;
     vmsSwapFileSize := 0;
@@ -443,7 +444,7 @@
 begin
   if (vmsSwapHandle <> 0) then begin
     FileClose(vmsSwapHandle);
-    DeleteFile(vmsSwapFileName);
+    mbDeleteFile(vmsSwapFileName);
     vmsSwapHandle := 0;
   end;
 end;
Index: AbZBrows.pas
===================================================================
--- AbZBrows.pas	(revision 512)
+++ AbZBrows.pas	(working copy)
@@ -129,7 +129,7 @@
 implementation
 
 uses
-  SysUtils, AbBzip2Typ, AbExcept, AbGzTyp, AbTarTyp, AbUtils;
+  SysUtils, AbBzip2Typ, AbExcept, AbGzTyp, AbTarTyp, AbUtils, DCOSUtils;
 
 { TAbCustomZipBrowser implementation ======================================= }
 
@@ -205,7 +205,7 @@
   FArchive := nil;
 
   if FileName <> '' then begin
-    if FileExists(FileName) then begin { open it }
+    if mbFileExists(FileName) then begin { open it }
       ArcType := ArchiveType;
       if not ForceType then
          ArcType := AbDetermineArcType(FileName, atUnknown);
Index: AbZipper.pas
===================================================================
--- AbZipper.pas	(revision 512)
+++ AbZipper.pas	(working copy)
@@ -173,7 +173,7 @@
 implementation
 
 uses
-  SysUtils, AbUtils, AbTarTyp, AbGzTyp, AbBzip2Typ, AbExcept, AbZipPrc;
+  SysUtils, AbUtils, AbTarTyp, AbGzTyp, AbBzip2Typ, AbExcept, AbZipPrc, DCOSUtils;
 
 { -------------------------------------------------------------------------- }
 constructor TAbCustomZipper.Create( AOwner : TComponent );
@@ -399,7 +399,7 @@
   ArcType := ArchiveType;
 
   if (FileName <> '') then
-    if FileExists(FileName) then begin { open it }
+    if mbFileExists(FileName) then begin { open it }
 
     if not ForceType then
       ArcType := AbDetermineArcType(FileName, atUnknown);
@@ -411,33 +411,33 @@
         end;
 
         atTar : begin
-          FArchive := TAbTarArchive.Create(FileName, fmOpenReadWrite or fmShareDenyNone);
+          FArchive := TAbTarArchive.Create(FileName, fmOpenRead or fmShareDenyNone);
           inherited InitArchive;
         end;
 
         atGZip : begin
-          FArchive := TAbGzipArchive.Create(FileName, fmOpenReadWrite or fmShareDenyNone);
+          FArchive := TAbGzipArchive.Create(FileName, fmOpenRead or fmShareDenyNone);
           TAbGzipArchive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbGzipArchive(FArchive).IsGzippedTar := False;
           inherited InitArchive;
         end;
 
         atGZippedTar : begin
-          FArchive := TAbGzipArchive.Create(FileName, fmOpenReadWrite or fmShareDenyNone);
+          FArchive := TAbGzipArchive.Create(FileName, fmOpenRead or fmShareDenyNone);
           TAbGzipArchive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbGzipArchive(FArchive).IsGzippedTar := True;
           inherited InitArchive;
         end;
 
         atBzip2 : begin
-          FArchive := TAbBzip2Archive.Create(FileName, fmOpenReadWrite or fmShareDenyNone);
+          FArchive := TAbBzip2Archive.Create(FileName, fmOpenRead or fmShareDenyNone);
           TAbBzip2Archive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbBzip2Archive(FArchive).IsBzippedTar := False;
           inherited InitArchive;
         end;
 
         atBzippedTar : begin
-          FArchive := TAbBzip2Archive.Create(FileName, fmOpenReadWrite or fmShareDenyNone);
+          FArchive := TAbBzip2Archive.Create(FileName, fmOpenRead or fmShareDenyNone);
           TAbBzip2Archive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbBzip2Archive(FArchive).IsBzippedTar := True;
           inherited InitArchive;
@@ -455,38 +455,38 @@
 
       case ArcType of
         atZip : begin                                                    
-          FArchive := TAbZipArchive.Create(FileName, fmCreate);
+          FArchive := TAbZipArchive.Create(FileName, fmCreate or fmShareDenyWrite);
           InitArchive;
         end;
 
         atTar : begin
-          FArchive := TAbTarArchive.Create(FileName, fmCreate or fmShareDenyNone);
+          FArchive := TAbTarArchive.Create(FileName, fmCreate or fmShareDenyWrite);
           inherited InitArchive;
         end;
 
         atGZip : begin
-          FArchive := TAbGzipArchive.Create(FileName, fmCreate or fmShareDenyNone);
+          FArchive := TAbGzipArchive.Create(FileName, fmCreate or fmShareDenyWrite);
           TAbGzipArchive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbGzipArchive(FArchive).IsGzippedTar := False;
           inherited InitArchive;
         end;
 
         atGZippedTar : begin
-          FArchive := TAbGzipArchive.Create(FileName, fmCreate or fmShareDenyNone);
+          FArchive := TAbGzipArchive.Create(FileName, fmCreate or fmShareDenyWrite);
           TAbGzipArchive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbGzipArchive(FArchive).IsGzippedTar := True;
           inherited InitArchive;
         end;
 
         atBzip2 : begin
-          FArchive := TAbBzip2Archive.Create(FileName, fmCreate or fmShareDenyNone);
+          FArchive := TAbBzip2Archive.Create(FileName, fmCreate or fmShareDenyWrite);
           TAbBzip2Archive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbBzip2Archive(FArchive).IsBzippedTar := False;
           inherited InitArchive;
         end;
 
         atBzippedTar : begin
-          FArchive := TAbBzip2Archive.Create(FileName, fmCreate or fmShareDenyNone);
+          FArchive := TAbBzip2Archive.Create(FileName, fmCreate or fmShareDenyWrite);
           TAbBzip2Archive(FArchive).TarAutoHandle := FTarAutoHandle;
           TAbBzip2Archive(FArchive).IsBzippedTar := True;
           inherited InitArchive;
Index: AbZipPrc.pas
===================================================================
--- AbZipPrc.pas	(revision 512)
+++ AbZipPrc.pas	(working copy)
@@ -67,7 +67,8 @@
   AbVMStrm,
   AbDfBase,
   AbDfEnc,
-  AbSpanSt;
+  AbSpanSt,
+  DCClassesUtf8;
 
 
 { ========================================================================== }
@@ -294,22 +295,13 @@
                  OutStream : TStream );
 var
   UncompressedStream : TStream;
-  SaveDir : string;
   AttrEx : TAbAttrExRec;
 begin
-  GetDir(0, SaveDir);
-  try {SaveDir}
-    if (Sender.BaseDirectory <> '') then
-      ChDir(Sender.BaseDirectory);
-    AbFileGetAttrEx(Item.DiskFileName, AttrEx);
-    if ((AttrEx.Attr and faDirectory) <> 0) then
-      UncompressedStream := TMemoryStream.Create
-    else
-      UncompressedStream :=
-        TFileStream.Create(Item.DiskFileName, fmOpenRead or fmShareDenyWrite);
-  finally {SaveDir}
-    ChDir( SaveDir );
-  end; {SaveDir}
+  AbFileGetAttrEx(Item.DiskFileName, AttrEx);
+  if ((AttrEx.Attr and faDirectory) <> 0) then
+    UncompressedStream := TMemoryStream.Create
+  else
+    UncompressedStream := TFileStreamEx.Create(Item.DiskFileName, fmOpenRead or fmShareDenyWrite);
   try {UncompressedStream}
     {$IFDEF UNIX}
     Item.ExternalFileAttributes := LongWord(AttrEx.Mode) shl 16 + LongWord(AttrEx.Attr);
